<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>sxmlc: /dataw/Workspaces/misc/sxmlc/src/sxmlc.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">sxmlc
   </div>
   <div id="projectbrief">Simple XML parser in C</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_fda9d7301690f9b272ccba5cf69d6c70.html">dataw</a></li><li class="navelem"><a class="el" href="dir_f7f1d87f788d0acec28992599f9bd7e5.html">Workspaces</a></li><li class="navelem"><a class="el" href="dir_4b6689a579d2bf6a780a7fe0e357ccad.html">misc</a></li><li class="navelem"><a class="el" href="dir_4aaa8af8a42883974f86be2bbb59bddf.html">sxmlc</a></li><li class="navelem"><a class="el" href="dir_748924e6c4498877de4c0c3463b653b9.html">src</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">sxmlc.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;stdio.h&gt;</code><br />
<code>#include &lt;stdlib.h&gt;</code><br />
<code>#include &lt;string.h&gt;</code><br />
<code>#include &lt;ctype.h&gt;</code><br />
<code>#include &quot;<a class="el" href="sxmlc_8h_source.html">sxmlc.h</a>&quot;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct___tag.html">_Tag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definition of "special" tags such as "&amp;lt;? ?&amp;gt;" or "&amp;lt;![CDATA[ ]]/&amp;gt;".  <a href="struct___tag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>_SpecialTag</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>_html_special_dict</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a369266c24eacffb87046522897a570d5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sxmlc_8c.html#a369266c24eacffb87046522897a570d5">_GNU_SOURCE</a></td></tr>
<tr class="separator:a369266c24eacffb87046522897a570d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ddf294660652cda8cc3a97d8f5ec673"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sxmlc_8c.html#a9ddf294660652cda8cc3a97d8f5ec673">CHECK_NODE</a>(node,  ret)&#160;&#160;&#160;if (!<a class="el" href="sxmlc_8h.html#a86aeb3e18254c5b36f76bdc347f07755">XMLNode_is_valid</a>(node)) return (ret)</td></tr>
<tr class="separator:a9ddf294660652cda8cc3a97d8f5ec673"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d1c0fce47efc47f8467afb2011fa428"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sxmlc_8c.html#a2d1c0fce47efc47f8467afb2011fa428">sx_isunicode</a>(c)&#160;&#160;&#160;((int)c &lt; 0 || (int)c &gt; 127)</td></tr>
<tr class="separator:a2d1c0fce47efc47f8467afb2011fa428"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:aa9ddab5df24a985eae6e66aedb6b1fb6"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct___tag.html">_Tag</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sxmlc_8c.html#aa9ddab5df24a985eae6e66aedb6b1fb6">_TAG</a></td></tr>
<tr class="memdesc:aa9ddab5df24a985eae6e66aedb6b1fb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definition of "special" tags such as "&amp;lt;? ?&amp;gt;" or "&amp;lt;![CDATA[ ]]/&amp;gt;".  <a href="sxmlc_8c.html#aa9ddab5df24a985eae6e66aedb6b1fb6">More...</a><br /></td></tr>
<tr class="separator:aa9ddab5df24a985eae6e66aedb6b1fb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a275a539b72263e0950ba2475f77b05ba"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sxmlc_8c.html#a275a539b72263e0950ba2475f77b05ba">XML_register_user_tag</a> (<a class="el" href="sxmlc_8h.html#ae5087224fc7c4f0dfabdd3ead8c91551">TagType</a> tag_type, <a class="el" href="sxmlc_8h.html#a1423a22b82d292ebd77caf61c520cdce">SXML_CHAR</a> *start, <a class="el" href="sxmlc_8h.html#a1423a22b82d292ebd77caf61c520cdce">SXML_CHAR</a> *end)</td></tr>
<tr class="memdesc:a275a539b72263e0950ba2475f77b05ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register an XML tag, giving its 'start' and 'end' string, which should include '&lt;' and '&gt;'.  <a href="sxmlc_8c.html#a275a539b72263e0950ba2475f77b05ba">More...</a><br /></td></tr>
<tr class="separator:a275a539b72263e0950ba2475f77b05ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ca0e0326bcae96bbcf8f5b24a9a184d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sxmlc_8c.html#a6ca0e0326bcae96bbcf8f5b24a9a184d">XML_unregister_user_tag</a> (int i_tag)</td></tr>
<tr class="memdesc:a6ca0e0326bcae96bbcf8f5b24a9a184d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a registered user tag.  <a href="sxmlc_8c.html#a6ca0e0326bcae96bbcf8f5b24a9a184d">More...</a><br /></td></tr>
<tr class="separator:a6ca0e0326bcae96bbcf8f5b24a9a184d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae46d39157e315e7f2a41c1b5bae8400d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sxmlc_8c.html#ae46d39157e315e7f2a41c1b5bae8400d">XML_get_nb_registered_user_tags</a> (void)</td></tr>
<tr class="memdesc:ae46d39157e315e7f2a41c1b5bae8400d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of user-defined tags.  <a href="sxmlc_8c.html#ae46d39157e315e7f2a41c1b5bae8400d">More...</a><br /></td></tr>
<tr class="separator:ae46d39157e315e7f2a41c1b5bae8400d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa925dc88370022fe7112fa2c4a7de732"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sxmlc_8c.html#aa925dc88370022fe7112fa2c4a7de732">XML_get_registered_user_tag</a> (<a class="el" href="sxmlc_8h.html#ae5087224fc7c4f0dfabdd3ead8c91551">TagType</a> tag_type)</td></tr>
<tr class="memdesc:aa925dc88370022fe7112fa2c4a7de732"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search for a user tag based on it type.  <a href="sxmlc_8c.html#aa925dc88370022fe7112fa2c4a7de732">More...</a><br /></td></tr>
<tr class="separator:aa925dc88370022fe7112fa2c4a7de732"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6707d1bb0e09196b21644e4d5b60663b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sxmlc_8c.html#a6707d1bb0e09196b21644e4d5b60663b">XMLNode_init</a> (<a class="el" href="sxmlc_8h.html#a2f1120f1eef3bddf7316ed256c0a36a8">XMLNode</a> *node)</td></tr>
<tr class="memdesc:a6707d1bb0e09196b21644e4d5b60663b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize an already-allocated XMLNode.  <a href="sxmlc_8c.html#a6707d1bb0e09196b21644e4d5b60663b">More...</a><br /></td></tr>
<tr class="separator:a6707d1bb0e09196b21644e4d5b60663b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20bcb360b343439e18f4fcdc15c4b9f3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sxmlc_8h.html#a2f1120f1eef3bddf7316ed256c0a36a8">XMLNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sxmlc_8c.html#a20bcb360b343439e18f4fcdc15c4b9f3">XMLNode_allocN</a> (int n)</td></tr>
<tr class="memdesc:a20bcb360b343439e18f4fcdc15c4b9f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate and initialize XML nodes.  <a href="sxmlc_8c.html#a20bcb360b343439e18f4fcdc15c4b9f3">More...</a><br /></td></tr>
<tr class="separator:a20bcb360b343439e18f4fcdc15c4b9f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ff8567100a02c6f9d6f8cacc00e8450"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sxmlc_8h.html#a2f1120f1eef3bddf7316ed256c0a36a8">XMLNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sxmlc_8c.html#a7ff8567100a02c6f9d6f8cacc00e8450">XMLNode_new</a> (const <a class="el" href="sxmlc_8h.html#ae5087224fc7c4f0dfabdd3ead8c91551">TagType</a> tag_type, const <a class="el" href="sxmlc_8h.html#a1423a22b82d292ebd77caf61c520cdce">SXML_CHAR</a> *tag, const <a class="el" href="sxmlc_8h.html#a1423a22b82d292ebd77caf61c520cdce">SXML_CHAR</a> *text)</td></tr>
<tr class="memdesc:a7ff8567100a02c6f9d6f8cacc00e8450"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate and initialize a new <code>XMLNode</code> of the given type, tag name and text.  <a href="sxmlc_8c.html#a7ff8567100a02c6f9d6f8cacc00e8450">More...</a><br /></td></tr>
<tr class="separator:a7ff8567100a02c6f9d6f8cacc00e8450"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac36bd02ca8769b16af03fc527dcb4ffb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sxmlc_8h.html#a2f1120f1eef3bddf7316ed256c0a36a8">XMLNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sxmlc_8c.html#ac36bd02ca8769b16af03fc527dcb4ffb">XMLNode_dup</a> (const <a class="el" href="sxmlc_8h.html#a2f1120f1eef3bddf7316ed256c0a36a8">XMLNode</a> *node, int copy_children)</td></tr>
<tr class="memdesc:ac36bd02ca8769b16af03fc527dcb4ffb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Duplicate a node, potentially with its children.  <a href="sxmlc_8c.html#ac36bd02ca8769b16af03fc527dcb4ffb">More...</a><br /></td></tr>
<tr class="separator:ac36bd02ca8769b16af03fc527dcb4ffb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a644c2517909786a6070de35ac52c977e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sxmlc_8c.html#a644c2517909786a6070de35ac52c977e">XMLNode_free</a> (<a class="el" href="sxmlc_8h.html#a2f1120f1eef3bddf7316ed256c0a36a8">XMLNode</a> *node)</td></tr>
<tr class="memdesc:a644c2517909786a6070de35ac52c977e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free a node and all its children.  <a href="sxmlc_8c.html#a644c2517909786a6070de35ac52c977e">More...</a><br /></td></tr>
<tr class="separator:a644c2517909786a6070de35ac52c977e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea53555f44a7b82bafbe9e174d32a42c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sxmlc_8c.html#aea53555f44a7b82bafbe9e174d32a42c">XMLNode_copy</a> (<a class="el" href="sxmlc_8h.html#a2f1120f1eef3bddf7316ed256c0a36a8">XMLNode</a> *dst, const <a class="el" href="sxmlc_8h.html#a2f1120f1eef3bddf7316ed256c0a36a8">XMLNode</a> *src, int copy_children)</td></tr>
<tr class="memdesc:aea53555f44a7b82bafbe9e174d32a42c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy a node to another one, optionally including its children.  <a href="sxmlc_8c.html#aea53555f44a7b82bafbe9e174d32a42c">More...</a><br /></td></tr>
<tr class="separator:aea53555f44a7b82bafbe9e174d32a42c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2efacd0f762ed6f686cac9458fb82fdb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sxmlc_8c.html#a2efacd0f762ed6f686cac9458fb82fdb">XMLNode_set_active</a> (<a class="el" href="sxmlc_8h.html#a2f1120f1eef3bddf7316ed256c0a36a8">XMLNode</a> *node, int active)</td></tr>
<tr class="memdesc:a2efacd0f762ed6f686cac9458fb82fdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the active/inactive state of <code>node</code>.  <a href="sxmlc_8c.html#a2efacd0f762ed6f686cac9458fb82fdb">More...</a><br /></td></tr>
<tr class="separator:a2efacd0f762ed6f686cac9458fb82fdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba9597ca92e8244c07e4dd156465cc9a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sxmlc_8c.html#aba9597ca92e8244c07e4dd156465cc9a">XMLNode_set_tag</a> (<a class="el" href="sxmlc_8h.html#a2f1120f1eef3bddf7316ed256c0a36a8">XMLNode</a> *node, const <a class="el" href="sxmlc_8h.html#a1423a22b82d292ebd77caf61c520cdce">SXML_CHAR</a> *tag)</td></tr>
<tr class="memdesc:aba9597ca92e8244c07e4dd156465cc9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set node tag.  <a href="sxmlc_8c.html#aba9597ca92e8244c07e4dd156465cc9a">More...</a><br /></td></tr>
<tr class="separator:aba9597ca92e8244c07e4dd156465cc9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd586c7c50c2159ed91304104d5bc6ec"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sxmlc_8c.html#acd586c7c50c2159ed91304104d5bc6ec">XMLNode_set_type</a> (<a class="el" href="sxmlc_8h.html#a2f1120f1eef3bddf7316ed256c0a36a8">XMLNode</a> *node, const <a class="el" href="sxmlc_8h.html#ae5087224fc7c4f0dfabdd3ead8c91551">TagType</a> tag_type)</td></tr>
<tr class="memdesc:acd586c7c50c2159ed91304104d5bc6ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the node type to one of <code>TagType</code> or any user-registered tag.  <a href="sxmlc_8c.html#acd586c7c50c2159ed91304104d5bc6ec">More...</a><br /></td></tr>
<tr class="separator:acd586c7c50c2159ed91304104d5bc6ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b07205691114194a903de14cfe7dca9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sxmlc_8c.html#a3b07205691114194a903de14cfe7dca9">XMLNode_set_attribute</a> (<a class="el" href="sxmlc_8h.html#a2f1120f1eef3bddf7316ed256c0a36a8">XMLNode</a> *node, const <a class="el" href="sxmlc_8h.html#a1423a22b82d292ebd77caf61c520cdce">SXML_CHAR</a> *attr_name, const <a class="el" href="sxmlc_8h.html#a1423a22b82d292ebd77caf61c520cdce">SXML_CHAR</a> *attr_value)</td></tr>
<tr class="memdesc:a3b07205691114194a903de14cfe7dca9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an attribute to a node or update an existing one.  <a href="sxmlc_8c.html#a3b07205691114194a903de14cfe7dca9">More...</a><br /></td></tr>
<tr class="separator:a3b07205691114194a903de14cfe7dca9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6df62789db1b726caaae280230570baa"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sxmlc_8c.html#a6df62789db1b726caaae280230570baa">XMLNode_get_attribute_with_default</a> (<a class="el" href="sxmlc_8h.html#a2f1120f1eef3bddf7316ed256c0a36a8">XMLNode</a> *node, const <a class="el" href="sxmlc_8h.html#a1423a22b82d292ebd77caf61c520cdce">SXML_CHAR</a> *attr_name, const <a class="el" href="sxmlc_8h.html#a1423a22b82d292ebd77caf61c520cdce">SXML_CHAR</a> **attr_value, const <a class="el" href="sxmlc_8h.html#a1423a22b82d292ebd77caf61c520cdce">SXML_CHAR</a> *default_attr_value)</td></tr>
<tr class="memdesc:a6df62789db1b726caaae280230570baa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve an attribute value, based on its name, returning a default value if the attribute does not exist.  <a href="sxmlc_8c.html#a6df62789db1b726caaae280230570baa">More...</a><br /></td></tr>
<tr class="separator:a6df62789db1b726caaae280230570baa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a781ed297ac9cadf8ba6cd60b328b1589"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sxmlc_8c.html#a781ed297ac9cadf8ba6cd60b328b1589">XMLNode_get_attribute_count</a> (const <a class="el" href="sxmlc_8h.html#a2f1120f1eef3bddf7316ed256c0a36a8">XMLNode</a> *node)</td></tr>
<tr class="separator:a781ed297ac9cadf8ba6cd60b328b1589"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae563536223635dcf4b8f8d5bf8bb4629"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sxmlc_8c.html#ae563536223635dcf4b8f8d5bf8bb4629">XMLNode_search_attribute</a> (const <a class="el" href="sxmlc_8h.html#a2f1120f1eef3bddf7316ed256c0a36a8">XMLNode</a> *node, const <a class="el" href="sxmlc_8h.html#a1423a22b82d292ebd77caf61c520cdce">SXML_CHAR</a> *attr_name, int i_search)</td></tr>
<tr class="memdesc:ae563536223635dcf4b8f8d5bf8bb4629"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search for the active attribute <code>attr_name</code> in <code>node</code>, starting from index <code>isearch</code> and returns its index, or -1 if not found or error.  <a href="sxmlc_8c.html#ae563536223635dcf4b8f8d5bf8bb4629">More...</a><br /></td></tr>
<tr class="separator:ae563536223635dcf4b8f8d5bf8bb4629"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3ceb2fb162c58ad3131cd7296d49d8c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sxmlc_8c.html#ab3ceb2fb162c58ad3131cd7296d49d8c">XMLNode_remove_attribute</a> (<a class="el" href="sxmlc_8h.html#a2f1120f1eef3bddf7316ed256c0a36a8">XMLNode</a> *node, int i_attr)</td></tr>
<tr class="memdesc:ab3ceb2fb162c58ad3131cd7296d49d8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove attribute index <code>i_attr</code>.  <a href="sxmlc_8c.html#ab3ceb2fb162c58ad3131cd7296d49d8c">More...</a><br /></td></tr>
<tr class="separator:ab3ceb2fb162c58ad3131cd7296d49d8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20aae5ac5789340ebc82c0f50ca5fa3e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sxmlc_8c.html#a20aae5ac5789340ebc82c0f50ca5fa3e">XMLNode_remove_all_attributes</a> (<a class="el" href="sxmlc_8h.html#a2f1120f1eef3bddf7316ed256c0a36a8">XMLNode</a> *node)</td></tr>
<tr class="memdesc:a20aae5ac5789340ebc82c0f50ca5fa3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all attributes from <code>node</code>.  <a href="sxmlc_8c.html#a20aae5ac5789340ebc82c0f50ca5fa3e">More...</a><br /></td></tr>
<tr class="separator:a20aae5ac5789340ebc82c0f50ca5fa3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab30f788b1b0ca3067e70fb1cfeb5567c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sxmlc_8c.html#ab30f788b1b0ca3067e70fb1cfeb5567c">XMLNode_set_text</a> (<a class="el" href="sxmlc_8h.html#a2f1120f1eef3bddf7316ed256c0a36a8">XMLNode</a> *node, const <a class="el" href="sxmlc_8h.html#a1423a22b82d292ebd77caf61c520cdce">SXML_CHAR</a> *text)</td></tr>
<tr class="separator:ab30f788b1b0ca3067e70fb1cfeb5567c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95015ebeffaec2d9f7c091c3ec50ba03"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sxmlc_8c.html#a95015ebeffaec2d9f7c091c3ec50ba03">XMLNode_add_child</a> (<a class="el" href="sxmlc_8h.html#a2f1120f1eef3bddf7316ed256c0a36a8">XMLNode</a> *node, <a class="el" href="sxmlc_8h.html#a2f1120f1eef3bddf7316ed256c0a36a8">XMLNode</a> *child)</td></tr>
<tr class="memdesc:a95015ebeffaec2d9f7c091c3ec50ba03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a child to a node.  <a href="sxmlc_8c.html#a95015ebeffaec2d9f7c091c3ec50ba03">More...</a><br /></td></tr>
<tr class="separator:a95015ebeffaec2d9f7c091c3ec50ba03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbe870babf239d4c2c0f6c38947fdb3f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sxmlc_8c.html#adbe870babf239d4c2c0f6c38947fdb3f">XMLNode_insert_child</a> (<a class="el" href="sxmlc_8h.html#a2f1120f1eef3bddf7316ed256c0a36a8">XMLNode</a> *node, <a class="el" href="sxmlc_8h.html#a2f1120f1eef3bddf7316ed256c0a36a8">XMLNode</a> *child, int index)</td></tr>
<tr class="memdesc:adbe870babf239d4c2c0f6c38947fdb3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a node at a given position.  <a href="sxmlc_8c.html#adbe870babf239d4c2c0f6c38947fdb3f">More...</a><br /></td></tr>
<tr class="separator:adbe870babf239d4c2c0f6c38947fdb3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a942aba2075bd42e2b5187f28116bd3ed"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sxmlc_8c.html#a942aba2075bd42e2b5187f28116bd3ed">XMLNode_move_child</a> (<a class="el" href="sxmlc_8h.html#a2f1120f1eef3bddf7316ed256c0a36a8">XMLNode</a> *node, int from, int to)</td></tr>
<tr class="memdesc:a942aba2075bd42e2b5187f28116bd3ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move a child node among its siblings.  <a href="sxmlc_8c.html#a942aba2075bd42e2b5187f28116bd3ed">More...</a><br /></td></tr>
<tr class="separator:a942aba2075bd42e2b5187f28116bd3ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3685d42addf2e84938b99e9874a99c44"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sxmlc_8c.html#a3685d42addf2e84938b99e9874a99c44">XMLNode_get_children_count</a> (const <a class="el" href="sxmlc_8h.html#a2f1120f1eef3bddf7316ed256c0a36a8">XMLNode</a> *node)</td></tr>
<tr class="memdesc:a3685d42addf2e84938b99e9874a99c44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of <em>active</em> children of a node.  <a href="sxmlc_8c.html#a3685d42addf2e84938b99e9874a99c44">More...</a><br /></td></tr>
<tr class="separator:a3685d42addf2e84938b99e9874a99c44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a164ce1cb11ba3d5776a4974897dd6478"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sxmlc_8c.html#a164ce1cb11ba3d5776a4974897dd6478">XMLNode_get_index</a> (const <a class="el" href="sxmlc_8h.html#a2f1120f1eef3bddf7316ed256c0a36a8">XMLNode</a> *node)</td></tr>
<tr class="memdesc:a164ce1cb11ba3d5776a4974897dd6478"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the node position among its <em>active</em> siblings.  <a href="sxmlc_8c.html#a164ce1cb11ba3d5776a4974897dd6478">More...</a><br /></td></tr>
<tr class="separator:a164ce1cb11ba3d5776a4974897dd6478"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84df156c286a932be44a5a86b00f5fbf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sxmlc_8h.html#a2f1120f1eef3bddf7316ed256c0a36a8">XMLNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sxmlc_8c.html#a84df156c286a932be44a5a86b00f5fbf">XMLNode_get_child</a> (const <a class="el" href="sxmlc_8h.html#a2f1120f1eef3bddf7316ed256c0a36a8">XMLNode</a> *node, int i_child)</td></tr>
<tr class="memdesc:a84df156c286a932be44a5a86b00f5fbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an <em>active</em> node.  <a href="sxmlc_8c.html#a84df156c286a932be44a5a86b00f5fbf">More...</a><br /></td></tr>
<tr class="separator:a84df156c286a932be44a5a86b00f5fbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0454f10aabaa5fca405118a0b5f11b7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sxmlc_8c.html#ad0454f10aabaa5fca405118a0b5f11b7">XMLNode_remove_child</a> (<a class="el" href="sxmlc_8h.html#a2f1120f1eef3bddf7316ed256c0a36a8">XMLNode</a> *node, int i_child, int free_child)</td></tr>
<tr class="memdesc:ad0454f10aabaa5fca405118a0b5f11b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the <code>i_child</code>th <em>active</em> child of the node.  <a href="sxmlc_8c.html#ad0454f10aabaa5fca405118a0b5f11b7">More...</a><br /></td></tr>
<tr class="separator:ad0454f10aabaa5fca405118a0b5f11b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a7a047035ceb0880423b4ec64350cd0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sxmlc_8c.html#a5a7a047035ceb0880423b4ec64350cd0">XMLNode_remove_children</a> (<a class="el" href="sxmlc_8h.html#a2f1120f1eef3bddf7316ed256c0a36a8">XMLNode</a> *node)</td></tr>
<tr class="memdesc:a5a7a047035ceb0880423b4ec64350cd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove (and frees) all children from the node.  <a href="sxmlc_8c.html#a5a7a047035ceb0880423b4ec64350cd0">More...</a><br /></td></tr>
<tr class="separator:a5a7a047035ceb0880423b4ec64350cd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa69f4b2b3ab62eb026d1fe4c231be2c0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sxmlc_8c.html#aa69f4b2b3ab62eb026d1fe4c231be2c0">XMLNode_equal</a> (const <a class="el" href="sxmlc_8h.html#a2f1120f1eef3bddf7316ed256c0a36a8">XMLNode</a> *node1, const <a class="el" href="sxmlc_8h.html#a2f1120f1eef3bddf7316ed256c0a36a8">XMLNode</a> *node2)</td></tr>
<tr class="separator:aa69f4b2b3ab62eb026d1fe4c231be2c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1564a1392d83360ac1a43d8f931bee13"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sxmlc_8h.html#a2f1120f1eef3bddf7316ed256c0a36a8">XMLNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sxmlc_8c.html#a1564a1392d83360ac1a43d8f931bee13">XMLNode_next_sibling</a> (const <a class="el" href="sxmlc_8h.html#a2f1120f1eef3bddf7316ed256c0a36a8">XMLNode</a> *node)</td></tr>
<tr class="memdesc:a1564a1392d83360ac1a43d8f931bee13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the next sibling node.  <a href="sxmlc_8c.html#a1564a1392d83360ac1a43d8f931bee13">More...</a><br /></td></tr>
<tr class="separator:a1564a1392d83360ac1a43d8f931bee13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ab1c34dac599dd896015f6cd9dbc7ef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sxmlc_8h.html#a2f1120f1eef3bddf7316ed256c0a36a8">XMLNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sxmlc_8c.html#a8ab1c34dac599dd896015f6cd9dbc7ef">XMLNode_next</a> (const <a class="el" href="sxmlc_8h.html#a2f1120f1eef3bddf7316ed256c0a36a8">XMLNode</a> *node)</td></tr>
<tr class="memdesc:a8ab1c34dac599dd896015f6cd9dbc7ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the "next" node: first child (if any) of next sibling otherwise.  <a href="sxmlc_8c.html#a8ab1c34dac599dd896015f6cd9dbc7ef">More...</a><br /></td></tr>
<tr class="separator:a8ab1c34dac599dd896015f6cd9dbc7ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21a1e3e99b13c66552d6cac05d64426c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sxmlc_8c.html#a21a1e3e99b13c66552d6cac05d64426c">XMLDoc_init</a> (<a class="el" href="sxmlc_8h.html#a4bf9d6033001ea055d09b23d31a6ba64">XMLDoc</a> *doc)</td></tr>
<tr class="memdesc:a21a1e3e99b13c66552d6cac05d64426c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes an already-allocated XML document.  <a href="sxmlc_8c.html#a21a1e3e99b13c66552d6cac05d64426c">More...</a><br /></td></tr>
<tr class="separator:a21a1e3e99b13c66552d6cac05d64426c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a398101d26edb8022fdf7ab884875975c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sxmlc_8c.html#a398101d26edb8022fdf7ab884875975c">XMLDoc_free</a> (<a class="el" href="sxmlc_8h.html#a4bf9d6033001ea055d09b23d31a6ba64">XMLDoc</a> *doc)</td></tr>
<tr class="memdesc:a398101d26edb8022fdf7ab884875975c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free an XML document, including all of its nodes, recursively.  <a href="sxmlc_8c.html#a398101d26edb8022fdf7ab884875975c">More...</a><br /></td></tr>
<tr class="separator:a398101d26edb8022fdf7ab884875975c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3236154594afe2bf16076aa82b610c81"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sxmlc_8c.html#a3236154594afe2bf16076aa82b610c81">XMLDoc_set_root</a> (<a class="el" href="sxmlc_8h.html#a4bf9d6033001ea055d09b23d31a6ba64">XMLDoc</a> *doc, int i_root)</td></tr>
<tr class="memdesc:a3236154594afe2bf16076aa82b610c81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the new document root node.  <a href="sxmlc_8c.html#a3236154594afe2bf16076aa82b610c81">More...</a><br /></td></tr>
<tr class="separator:a3236154594afe2bf16076aa82b610c81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dec7705c5543e70c8a59817570e689f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sxmlc_8c.html#a7dec7705c5543e70c8a59817570e689f">XMLDoc_add_node</a> (<a class="el" href="sxmlc_8h.html#a4bf9d6033001ea055d09b23d31a6ba64">XMLDoc</a> *doc, <a class="el" href="sxmlc_8h.html#a2f1120f1eef3bddf7316ed256c0a36a8">XMLNode</a> *node)</td></tr>
<tr class="memdesc:a7dec7705c5543e70c8a59817570e689f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a node to the document.  <a href="sxmlc_8c.html#a7dec7705c5543e70c8a59817570e689f">More...</a><br /></td></tr>
<tr class="separator:a7dec7705c5543e70c8a59817570e689f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a742fd7c60f31ec6aea0412b5fa7fcf03"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sxmlc_8c.html#a742fd7c60f31ec6aea0412b5fa7fcf03">XMLDoc_remove_node</a> (<a class="el" href="sxmlc_8h.html#a4bf9d6033001ea055d09b23d31a6ba64">XMLDoc</a> *doc, int i_node, int free_node)</td></tr>
<tr class="memdesc:a742fd7c60f31ec6aea0412b5fa7fcf03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a node from the document root nodes. Inactive nodes can be removed like this.  <a href="sxmlc_8c.html#a742fd7c60f31ec6aea0412b5fa7fcf03">More...</a><br /></td></tr>
<tr class="separator:a742fd7c60f31ec6aea0412b5fa7fcf03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4683e10b0452f1fc9e7d961e0557a50c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sxmlc_8c.html#a4683e10b0452f1fc9e7d961e0557a50c">XMLNode_print_header</a> (const <a class="el" href="sxmlc_8h.html#a2f1120f1eef3bddf7316ed256c0a36a8">XMLNode</a> *node, FILE *f, int sz_line, int nb_char_tab)</td></tr>
<tr class="memdesc:a4683e10b0452f1fc9e7d961e0557a50c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print the node "header": <code>&lt;tagname attribname="attibval" ...[/]&gt;</code>, spanning it on several lines if needed.  <a href="sxmlc_8c.html#a4683e10b0452f1fc9e7d961e0557a50c">More...</a><br /></td></tr>
<tr class="separator:a4683e10b0452f1fc9e7d961e0557a50c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9613d008088e8f02f49f30baf670e19f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sxmlc_8c.html#a9613d008088e8f02f49f30baf670e19f">XMLNode_print_attr_sep</a> (const <a class="el" href="sxmlc_8h.html#a2f1120f1eef3bddf7316ed256c0a36a8">XMLNode</a> *node, FILE *f, const <a class="el" href="sxmlc_8h.html#a1423a22b82d292ebd77caf61c520cdce">SXML_CHAR</a> *tag_sep, const <a class="el" href="sxmlc_8h.html#a1423a22b82d292ebd77caf61c520cdce">SXML_CHAR</a> *child_sep, const <a class="el" href="sxmlc_8h.html#a1423a22b82d292ebd77caf61c520cdce">SXML_CHAR</a> *attr_sep, int keep_text_spaces, int sz_line, int nb_char_tab)</td></tr>
<tr class="memdesc:a9613d008088e8f02f49f30baf670e19f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print the node and its children to a file (that can be <code>stdout</code>).  <a href="sxmlc_8c.html#a9613d008088e8f02f49f30baf670e19f">More...</a><br /></td></tr>
<tr class="separator:a9613d008088e8f02f49f30baf670e19f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b5dd76b23961f168296460abeb58bff"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sxmlc_8c.html#a5b5dd76b23961f168296460abeb58bff">XMLDoc_print_attr_sep</a> (const <a class="el" href="sxmlc_8h.html#a4bf9d6033001ea055d09b23d31a6ba64">XMLDoc</a> *doc, FILE *f, const <a class="el" href="sxmlc_8h.html#a1423a22b82d292ebd77caf61c520cdce">SXML_CHAR</a> *tag_sep, const <a class="el" href="sxmlc_8h.html#a1423a22b82d292ebd77caf61c520cdce">SXML_CHAR</a> *child_sep, const <a class="el" href="sxmlc_8h.html#a1423a22b82d292ebd77caf61c520cdce">SXML_CHAR</a> *attr_sep, int keep_text_spaces, int sz_line, int nb_char_tab)</td></tr>
<tr class="memdesc:a5b5dd76b23961f168296460abeb58bff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints the XML document using <code><a class="el" href="sxmlc_8h.html#a9613d008088e8f02f49f30baf670e19f" title="Print the node and its children to a file (that can be stdout).">XMLNode_print_attr_sep()</a></code> on all document nodes.  <a href="sxmlc_8c.html#a5b5dd76b23961f168296460abeb58bff">More...</a><br /></td></tr>
<tr class="separator:a5b5dd76b23961f168296460abeb58bff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7552ee06f68e1d6222f68f84921c8017"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sxmlc_8c.html#a7552ee06f68e1d6222f68f84921c8017">XML_parse_attribute_to</a> (const <a class="el" href="sxmlc_8h.html#a1423a22b82d292ebd77caf61c520cdce">SXML_CHAR</a> *str, int to, <a class="el" href="sxmlc_8h.html#a195d94c80e0524f308039447aea2e8e9">XMLAttribute</a> *xmlattr)</td></tr>
<tr class="memdesc:a7552ee06f68e1d6222f68f84921c8017"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse an attribute to an <code>XMLAttribute</code> struct.  <a href="sxmlc_8c.html#a7552ee06f68e1d6222f68f84921c8017">More...</a><br /></td></tr>
<tr class="separator:a7552ee06f68e1d6222f68f84921c8017"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad60acb82ff12a2142cff3ce43b02ed56"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sxmlc_8h.html#ae5087224fc7c4f0dfabdd3ead8c91551">TagType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sxmlc_8c.html#ad60acb82ff12a2142cff3ce43b02ed56">XML_parse_1string</a> (const <a class="el" href="sxmlc_8h.html#a1423a22b82d292ebd77caf61c520cdce">SXML_CHAR</a> *str, <a class="el" href="sxmlc_8h.html#a2f1120f1eef3bddf7316ed256c0a36a8">XMLNode</a> *xmlnode)</td></tr>
<tr class="memdesc:ad60acb82ff12a2142cff3ce43b02ed56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a string that is supposed to be an xml tag like <code>&lt;tag (attribName="attribValue")* [/]&gt;</code> or <code>&lt;/tag&gt;</code>.  <a href="sxmlc_8c.html#ad60acb82ff12a2142cff3ce43b02ed56">More...</a><br /></td></tr>
<tr class="separator:ad60acb82ff12a2142cff3ce43b02ed56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a18a78b9d6d2a64df6fa37305ab2048"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sxmlc_8c.html#a0a18a78b9d6d2a64df6fa37305ab2048">SAX_Callbacks_init</a> (<a class="el" href="sxmlc_8h.html#ad7a08824953657fdffaa58e3e23ad133">SAX_Callbacks</a> *sax)</td></tr>
<tr class="memdesc:a0a18a78b9d6d2a64df6fa37305ab2048"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to initialize all <code>sax</code> members to <code>NULL</code>.  <a href="sxmlc_8c.html#a0a18a78b9d6d2a64df6fa37305ab2048">More...</a><br /></td></tr>
<tr class="separator:a0a18a78b9d6d2a64df6fa37305ab2048"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af27428a88931b4e019aae88c59f4e707"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sxmlc_8c.html#af27428a88931b4e019aae88c59f4e707">DOMXMLDoc_doc_start</a> (<a class="el" href="sxmlc_8h.html#a32544a7962d023ebfcb7f8965c3a0cd2">SAX_Data</a> *sd)</td></tr>
<tr class="separator:af27428a88931b4e019aae88c59f4e707"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cb71e4da6968fd3c8e667f83ff49999"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sxmlc_8c.html#a2cb71e4da6968fd3c8e667f83ff49999">DOMXMLDoc_node_start</a> (const <a class="el" href="sxmlc_8h.html#a2f1120f1eef3bddf7316ed256c0a36a8">XMLNode</a> *node, <a class="el" href="sxmlc_8h.html#a32544a7962d023ebfcb7f8965c3a0cd2">SAX_Data</a> *sd)</td></tr>
<tr class="separator:a2cb71e4da6968fd3c8e667f83ff49999"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab01efda124cc18ad9f4933fb60d878b9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sxmlc_8c.html#ab01efda124cc18ad9f4933fb60d878b9">DOMXMLDoc_node_end</a> (const <a class="el" href="sxmlc_8h.html#a2f1120f1eef3bddf7316ed256c0a36a8">XMLNode</a> *node, <a class="el" href="sxmlc_8h.html#a32544a7962d023ebfcb7f8965c3a0cd2">SAX_Data</a> *sd)</td></tr>
<tr class="separator:ab01efda124cc18ad9f4933fb60d878b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1189ca84e3c97166cc9ba093b1f441fe"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sxmlc_8c.html#a1189ca84e3c97166cc9ba093b1f441fe">DOMXMLDoc_node_text</a> (<a class="el" href="sxmlc_8h.html#a1423a22b82d292ebd77caf61c520cdce">SXML_CHAR</a> *text, <a class="el" href="sxmlc_8h.html#a32544a7962d023ebfcb7f8965c3a0cd2">SAX_Data</a> *sd)</td></tr>
<tr class="separator:a1189ca84e3c97166cc9ba093b1f441fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35513e464f4cea22b77a02daa358e080"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sxmlc_8c.html#a35513e464f4cea22b77a02daa358e080">DOMXMLDoc_parse_error</a> (<a class="el" href="sxmlc_8h.html#ad59c4cc2ea957703962ae9aadbc1baa2">ParseError</a> error_num, int line_number, <a class="el" href="sxmlc_8h.html#a32544a7962d023ebfcb7f8965c3a0cd2">SAX_Data</a> *sd)</td></tr>
<tr class="separator:a35513e464f4cea22b77a02daa358e080"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9484f4dce531a04eaa114f175872b173"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sxmlc_8c.html#a9484f4dce531a04eaa114f175872b173">DOMXMLDoc_doc_end</a> (<a class="el" href="sxmlc_8h.html#a32544a7962d023ebfcb7f8965c3a0cd2">SAX_Data</a> *sd)</td></tr>
<tr class="separator:a9484f4dce531a04eaa114f175872b173"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a273e4ee4bf16ec891d82a3d0081550f3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sxmlc_8c.html#a273e4ee4bf16ec891d82a3d0081550f3">SAX_Callbacks_init_DOM</a> (<a class="el" href="sxmlc_8h.html#ad7a08824953657fdffaa58e3e23ad133">SAX_Callbacks</a> *sax)</td></tr>
<tr class="memdesc:a273e4ee4bf16ec891d82a3d0081550f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize <code>sax</code> with the "official" DOM callbacks.  <a href="sxmlc_8c.html#a273e4ee4bf16ec891d82a3d0081550f3">More...</a><br /></td></tr>
<tr class="separator:a273e4ee4bf16ec891d82a3d0081550f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4771d1652213454ede544a5d63c1f916"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sxmlc_8c.html#a4771d1652213454ede544a5d63c1f916">XMLDoc_parse_file_SAX</a> (const <a class="el" href="sxmlc_8h.html#a1423a22b82d292ebd77caf61c520cdce">SXML_CHAR</a> *filename, const <a class="el" href="sxmlc_8h.html#ad7a08824953657fdffaa58e3e23ad133">SAX_Callbacks</a> *sax, void *user)</td></tr>
<tr class="memdesc:a4771d1652213454ede544a5d63c1f916"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse an XML file, calling SAX callbacks.  <a href="sxmlc_8c.html#a4771d1652213454ede544a5d63c1f916">More...</a><br /></td></tr>
<tr class="separator:a4771d1652213454ede544a5d63c1f916"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51bca4f7f1fd4957b1367ad0e1882e9d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sxmlc_8c.html#a51bca4f7f1fd4957b1367ad0e1882e9d">XMLDoc_parse_buffer_SAX_len</a> (const <a class="el" href="sxmlc_8h.html#a1423a22b82d292ebd77caf61c520cdce">SXML_CHAR</a> *buffer, int buffer_len, const <a class="el" href="sxmlc_8h.html#a1423a22b82d292ebd77caf61c520cdce">SXML_CHAR</a> *name, const <a class="el" href="sxmlc_8h.html#ad7a08824953657fdffaa58e3e23ad133">SAX_Callbacks</a> *sax, void *user)</td></tr>
<tr class="memdesc:a51bca4f7f1fd4957b1367ad0e1882e9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse an XML buffer, calling SAX callbacks.  <a href="sxmlc_8c.html#a51bca4f7f1fd4957b1367ad0e1882e9d">More...</a><br /></td></tr>
<tr class="separator:a51bca4f7f1fd4957b1367ad0e1882e9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae64f70bcc3133a9542c7d05d65bc2602"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sxmlc_8c.html#ae64f70bcc3133a9542c7d05d65bc2602">XMLDoc_parse_file_DOM_text_as_nodes</a> (const <a class="el" href="sxmlc_8h.html#a1423a22b82d292ebd77caf61c520cdce">SXML_CHAR</a> *filename, <a class="el" href="sxmlc_8h.html#a4bf9d6033001ea055d09b23d31a6ba64">XMLDoc</a> *doc, int text_as_nodes)</td></tr>
<tr class="memdesc:ae64f70bcc3133a9542c7d05d65bc2602"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a file into an initialized XML document (DOM mode).  <a href="sxmlc_8c.html#ae64f70bcc3133a9542c7d05d65bc2602">More...</a><br /></td></tr>
<tr class="separator:ae64f70bcc3133a9542c7d05d65bc2602"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada0f9853892402f894957e946878cb09"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sxmlc_8c.html#ada0f9853892402f894957e946878cb09">XMLDoc_parse_buffer_DOM_text_as_nodes</a> (const <a class="el" href="sxmlc_8h.html#a1423a22b82d292ebd77caf61c520cdce">SXML_CHAR</a> *buffer, const <a class="el" href="sxmlc_8h.html#a1423a22b82d292ebd77caf61c520cdce">SXML_CHAR</a> *name, <a class="el" href="sxmlc_8h.html#a4bf9d6033001ea055d09b23d31a6ba64">XMLDoc</a> *doc, int text_as_nodes)</td></tr>
<tr class="memdesc:ada0f9853892402f894957e946878cb09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a memory buffer into an initialized document (DOM mode).  <a href="sxmlc_8c.html#ada0f9853892402f894957e946878cb09">More...</a><br /></td></tr>
<tr class="separator:ada0f9853892402f894957e946878cb09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc0b0fcfdb63a246b8ab9ca9abcdafaa"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sxmlc_8c.html#adc0b0fcfdb63a246b8ab9ca9abcdafaa">_beob</a> (<a class="el" href="sxmlc_8h.html#ab7ffe9e3f0fdede064caf8c0f407e836">DataSourceBuffer</a> *ds)</td></tr>
<tr class="memdesc:adc0b0fcfdb63a246b8ab9ca9abcdafaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">know if the end has been reached in a data source.  <a href="sxmlc_8c.html#adc0b0fcfdb63a246b8ab9ca9abcdafaa">More...</a><br /></td></tr>
<tr class="separator:adc0b0fcfdb63a246b8ab9ca9abcdafaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62833d15805746163daffad66ce52c2f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sxmlc_8c.html#a62833d15805746163daffad66ce52c2f">_bgetc</a> (<a class="el" href="sxmlc_8h.html#ab7ffe9e3f0fdede064caf8c0f407e836">DataSourceBuffer</a> *ds)</td></tr>
<tr class="memdesc:a62833d15805746163daffad66ce52c2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get next byte from data source.  <a href="sxmlc_8c.html#a62833d15805746163daffad66ce52c2f">More...</a><br /></td></tr>
<tr class="separator:a62833d15805746163daffad66ce52c2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a964bbbfb2ebc796412fecd7aed243eb6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sxmlc_8c.html#a964bbbfb2ebc796412fecd7aed243eb6">read_line_alloc</a> (void *in, <a class="el" href="sxmlc_8h.html#a41734f8def67b21870b6fd8ceb153fb5">DataSourceType</a> in_type, <a class="el" href="sxmlc_8h.html#a1423a22b82d292ebd77caf61c520cdce">SXML_CHAR</a> **line, int *sz_line, int i0, <a class="el" href="sxmlc_8h.html#a1423a22b82d292ebd77caf61c520cdce">SXML_CHAR</a> from, <a class="el" href="sxmlc_8h.html#a1423a22b82d292ebd77caf61c520cdce">SXML_CHAR</a> to, int keep_fromto, <a class="el" href="sxmlc_8h.html#a1423a22b82d292ebd77caf61c520cdce">SXML_CHAR</a> interest, int *interest_count)</td></tr>
<tr class="memdesc:a964bbbfb2ebc796412fecd7aed243eb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a "line" from data source, eventually (re-)allocating a given buffer. A "line" is defined as a portion starting with character <code>from</code> (usually <code>&lt;</code>) ending at character <code>to</code> (usually <code>&gt;</code>).  <a href="sxmlc_8c.html#a964bbbfb2ebc796412fecd7aed243eb6">More...</a><br /></td></tr>
<tr class="separator:a964bbbfb2ebc796412fecd7aed243eb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b0d9802839e6529a7212a631cb2d2d8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sxmlc_8h.html#a1423a22b82d292ebd77caf61c520cdce">SXML_CHAR</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sxmlc_8c.html#a6b0d9802839e6529a7212a631cb2d2d8">strcat_alloc</a> (<a class="el" href="sxmlc_8h.html#a1423a22b82d292ebd77caf61c520cdce">SXML_CHAR</a> **src1, const <a class="el" href="sxmlc_8h.html#a1423a22b82d292ebd77caf61c520cdce">SXML_CHAR</a> *src2)</td></tr>
<tr class="memdesc:a6b0d9802839e6529a7212a631cb2d2d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenates the string pointed at by <code>src1</code> with <code>src2</code> into <code>*src1</code> and return it.  <a href="sxmlc_8c.html#a6b0d9802839e6529a7212a631cb2d2d8">More...</a><br /></td></tr>
<tr class="separator:a6b0d9802839e6529a7212a631cb2d2d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7de2f042b023b40a9961f8453a2efee9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sxmlc_8h.html#a1423a22b82d292ebd77caf61c520cdce">SXML_CHAR</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sxmlc_8c.html#a7de2f042b023b40a9961f8453a2efee9">strip_spaces</a> (<a class="el" href="sxmlc_8h.html#a1423a22b82d292ebd77caf61c520cdce">SXML_CHAR</a> *str, <a class="el" href="sxmlc_8h.html#a1423a22b82d292ebd77caf61c520cdce">SXML_CHAR</a> repl_sq)</td></tr>
<tr class="memdesc:a7de2f042b023b40a9961f8453a2efee9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Strip whitespaces at the beginning and end of a string, modifying it.  <a href="sxmlc_8c.html#a7de2f042b023b40a9961f8453a2efee9">More...</a><br /></td></tr>
<tr class="separator:a7de2f042b023b40a9961f8453a2efee9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72c65b1ce14f2a5f472cae742d2cfc54"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sxmlc_8h.html#a1423a22b82d292ebd77caf61c520cdce">SXML_CHAR</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sxmlc_8c.html#a72c65b1ce14f2a5f472cae742d2cfc54">str_unescape</a> (<a class="el" href="sxmlc_8h.html#a1423a22b82d292ebd77caf61c520cdce">SXML_CHAR</a> *str)</td></tr>
<tr class="memdesc:a72c65b1ce14f2a5f472cae742d2cfc54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove <code>\</code> characters from <code>str</code>, modifying it.  <a href="sxmlc_8c.html#a72c65b1ce14f2a5f472cae742d2cfc54">More...</a><br /></td></tr>
<tr class="separator:a72c65b1ce14f2a5f472cae742d2cfc54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15be9d3babba0d1e04cc13dfaba83cfb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sxmlc_8c.html#a15be9d3babba0d1e04cc13dfaba83cfb">split_left_right</a> (<a class="el" href="sxmlc_8h.html#a1423a22b82d292ebd77caf61c520cdce">SXML_CHAR</a> *str, <a class="el" href="sxmlc_8h.html#a1423a22b82d292ebd77caf61c520cdce">SXML_CHAR</a> sep, int *l0, int *l1, int *i_sep, int *r0, int *r1, int ignore_spaces, int ignore_quotes)</td></tr>
<tr class="memdesc:a15be9d3babba0d1e04cc13dfaba83cfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split a string into a left and right part around a given separator.  <a href="sxmlc_8c.html#a15be9d3babba0d1e04cc13dfaba83cfb">More...</a><br /></td></tr>
<tr class="separator:a15be9d3babba0d1e04cc13dfaba83cfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2934d246cfa7a2ceef8632d88d34fff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sxmlc_8h.html#a0913f5fe1a761447a2a0dc3befe9d616">BOM_TYPE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sxmlc_8c.html#aa2934d246cfa7a2ceef8632d88d34fff">freadBOM</a> (FILE *f, unsigned char *bom, int *sz_bom)</td></tr>
<tr class="separator:aa2934d246cfa7a2ceef8632d88d34fff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b4e6316cf02c49046585daa9ff89af9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sxmlc_8c.html#a6b4e6316cf02c49046585daa9ff89af9">has_html</a> (<a class="el" href="sxmlc_8h.html#a1423a22b82d292ebd77caf61c520cdce">SXML_CHAR</a> *html)</td></tr>
<tr class="memdesc:a6b4e6316cf02c49046585daa9ff89af9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given string contains HTML escape character (<code>&amp;</code>).  <a href="sxmlc_8c.html#a6b4e6316cf02c49046585daa9ff89af9">More...</a><br /></td></tr>
<tr class="separator:a6b4e6316cf02c49046585daa9ff89af9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfecfdb1904fbb7770e7fba2778bfa78"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sxmlc_8h.html#a1423a22b82d292ebd77caf61c520cdce">SXML_CHAR</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sxmlc_8c.html#acfecfdb1904fbb7770e7fba2778bfa78">html2str</a> (<a class="el" href="sxmlc_8h.html#a1423a22b82d292ebd77caf61c520cdce">SXML_CHAR</a> *html, <a class="el" href="sxmlc_8h.html#a1423a22b82d292ebd77caf61c520cdce">SXML_CHAR</a> *str)</td></tr>
<tr class="memdesc:acfecfdb1904fbb7770e7fba2778bfa78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace occurrences of special HTML characters escape sequences (e.g. <code>"&amp;amp;"</code>) by its character equivalent (e.g. <code>"&amp;"</code>).  <a href="sxmlc_8c.html#acfecfdb1904fbb7770e7fba2778bfa78">More...</a><br /></td></tr>
<tr class="separator:acfecfdb1904fbb7770e7fba2778bfa78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac87b7e66127a27a127395aa46010c601"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sxmlc_8h.html#a1423a22b82d292ebd77caf61c520cdce">SXML_CHAR</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sxmlc_8c.html#ac87b7e66127a27a127395aa46010c601">str2html</a> (<a class="el" href="sxmlc_8h.html#a1423a22b82d292ebd77caf61c520cdce">SXML_CHAR</a> *str, <a class="el" href="sxmlc_8h.html#a1423a22b82d292ebd77caf61c520cdce">SXML_CHAR</a> *html)</td></tr>
<tr class="memdesc:ac87b7e66127a27a127395aa46010c601"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace occurrences of special characters (e.g. <code>&amp;</code>) into their XML escaped equivalent (e.g. <code>"&amp;amp;"</code>).  <a href="sxmlc_8c.html#ac87b7e66127a27a127395aa46010c601">More...</a><br /></td></tr>
<tr class="separator:ac87b7e66127a27a127395aa46010c601"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09f4a29baaef565145cfa0134b00a4c9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sxmlc_8c.html#a09f4a29baaef565145cfa0134b00a4c9">strlen_html</a> (<a class="el" href="sxmlc_8h.html#a1423a22b82d292ebd77caf61c520cdce">SXML_CHAR</a> *str)</td></tr>
<tr class="memdesc:a09f4a29baaef565145cfa0134b00a4c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the length of a string as if all its special character were replaced by their HTML escapes.  <a href="sxmlc_8c.html#a09f4a29baaef565145cfa0134b00a4c9">More...</a><br /></td></tr>
<tr class="separator:a09f4a29baaef565145cfa0134b00a4c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5439ff450cc679ca44f3e45080dd7406"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sxmlc_8c.html#a5439ff450cc679ca44f3e45080dd7406">fprintHTML</a> (FILE *f, <a class="el" href="sxmlc_8h.html#a1423a22b82d292ebd77caf61c520cdce">SXML_CHAR</a> *str)</td></tr>
<tr class="memdesc:a5439ff450cc679ca44f3e45080dd7406"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print a string to a file, transforming special characters into their HTML equivalent.  <a href="sxmlc_8c.html#a5439ff450cc679ca44f3e45080dd7406">More...</a><br /></td></tr>
<tr class="separator:a5439ff450cc679ca44f3e45080dd7406"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d9dc791bef89eef2f2d463233c0d6b8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sxmlc_8c.html#a4d9dc791bef89eef2f2d463233c0d6b8">regstrcmp</a> (<a class="el" href="sxmlc_8h.html#a1423a22b82d292ebd77caf61c520cdce">SXML_CHAR</a> *str, <a class="el" href="sxmlc_8h.html#a1423a22b82d292ebd77caf61c520cdce">SXML_CHAR</a> *pattern)</td></tr>
<tr class="separator:a4d9dc791bef89eef2f2d463233c0d6b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a369266c24eacffb87046522897a570d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a369266c24eacffb87046522897a570d5">&#9670;&nbsp;</a></span>_GNU_SOURCE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _GNU_SOURCE</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9ddf294660652cda8cc3a97d8f5ec673"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ddf294660652cda8cc3a97d8f5ec673">&#9670;&nbsp;</a></span>CHECK_NODE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CHECK_NODE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">node, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ret&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;if (!<a class="el" href="sxmlc_8h.html#a86aeb3e18254c5b36f76bdc347f07755">XMLNode_is_valid</a>(node)) return (ret)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2d1c0fce47efc47f8467afb2011fa428"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d1c0fce47efc47f8467afb2011fa428">&#9670;&nbsp;</a></span>sx_isunicode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define sx_isunicode</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">c</td><td>)</td>
          <td>&#160;&#160;&#160;((int)c &lt; 0 || (int)c &gt; 127)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="aa9ddab5df24a985eae6e66aedb6b1fb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9ddab5df24a985eae6e66aedb6b1fb6">&#9670;&nbsp;</a></span>_TAG</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct___tag.html">_Tag</a> <a class="el" href="sxmlc_8c.html#aa9ddab5df24a985eae6e66aedb6b1fb6">_TAG</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition of "special" tags such as "&amp;lt;? ?&amp;gt;" or "&amp;lt;![CDATA[ ]]/&amp;gt;". </p>
<p>These tags are considered having a start and an end with some data in between that will be stored in the 'tag' member of an XMLNode. The <code>tag_type</code> member is a constant that is associated to such tag. All <code>len_*</code> members are basically the "sx_strlen()" of 'start' and 'end' members. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="adc0b0fcfdb63a246b8ab9ca9abcdafaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc0b0fcfdb63a246b8ab9ca9abcdafaa">&#9670;&nbsp;</a></span>_beob()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int _beob </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sxmlc_8h.html#ab7ffe9e3f0fdede064caf8c0f407e836">DataSourceBuffer</a> *&#160;</td>
          <td class="paramname"><em>ds</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>know if the end has been reached in a data source. </p>
<dl class="section return"><dt>Returns</dt><dd>as <code>feof()</code> would for <code>FILE*</code>. </dd></dl>

</div>
</div>
<a id="a62833d15805746163daffad66ce52c2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62833d15805746163daffad66ce52c2f">&#9670;&nbsp;</a></span>_bgetc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int _bgetc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sxmlc_8h.html#ab7ffe9e3f0fdede064caf8c0f407e836">DataSourceBuffer</a> *&#160;</td>
          <td class="paramname"><em>ds</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get next byte from data source. </p>
<dl class="section return"><dt>Returns</dt><dd>as <code>fgetc()</code> would for <code>FILE*</code>. </dd></dl>

</div>
</div>
<a id="a9484f4dce531a04eaa114f175872b173"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9484f4dce531a04eaa114f175872b173">&#9670;&nbsp;</a></span>DOMXMLDoc_doc_end()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int DOMXMLDoc_doc_end </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sxmlc_8h.html#a32544a7962d023ebfcb7f8965c3a0cd2">SAX_Data</a> *&#160;</td>
          <td class="paramname"><em>sd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af27428a88931b4e019aae88c59f4e707"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af27428a88931b4e019aae88c59f4e707">&#9670;&nbsp;</a></span>DOMXMLDoc_doc_start()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int DOMXMLDoc_doc_start </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sxmlc_8h.html#a32544a7962d023ebfcb7f8965c3a0cd2">SAX_Data</a> *&#160;</td>
          <td class="paramname"><em>sd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab01efda124cc18ad9f4933fb60d878b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab01efda124cc18ad9f4933fb60d878b9">&#9670;&nbsp;</a></span>DOMXMLDoc_node_end()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int DOMXMLDoc_node_end </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="sxmlc_8h.html#a2f1120f1eef3bddf7316ed256c0a36a8">XMLNode</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sxmlc_8h.html#a32544a7962d023ebfcb7f8965c3a0cd2">SAX_Data</a> *&#160;</td>
          <td class="paramname"><em>sd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2cb71e4da6968fd3c8e667f83ff49999"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cb71e4da6968fd3c8e667f83ff49999">&#9670;&nbsp;</a></span>DOMXMLDoc_node_start()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int DOMXMLDoc_node_start </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="sxmlc_8h.html#a2f1120f1eef3bddf7316ed256c0a36a8">XMLNode</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sxmlc_8h.html#a32544a7962d023ebfcb7f8965c3a0cd2">SAX_Data</a> *&#160;</td>
          <td class="paramname"><em>sd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1189ca84e3c97166cc9ba093b1f441fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1189ca84e3c97166cc9ba093b1f441fe">&#9670;&nbsp;</a></span>DOMXMLDoc_node_text()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int DOMXMLDoc_node_text </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sxmlc_8h.html#a1423a22b82d292ebd77caf61c520cdce">SXML_CHAR</a> *&#160;</td>
          <td class="paramname"><em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sxmlc_8h.html#a32544a7962d023ebfcb7f8965c3a0cd2">SAX_Data</a> *&#160;</td>
          <td class="paramname"><em>sd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a35513e464f4cea22b77a02daa358e080"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35513e464f4cea22b77a02daa358e080">&#9670;&nbsp;</a></span>DOMXMLDoc_parse_error()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int DOMXMLDoc_parse_error </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sxmlc_8h.html#ad59c4cc2ea957703962ae9aadbc1baa2">ParseError</a>&#160;</td>
          <td class="paramname"><em>error_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>line_number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sxmlc_8h.html#a32544a7962d023ebfcb7f8965c3a0cd2">SAX_Data</a> *&#160;</td>
          <td class="paramname"><em>sd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5439ff450cc679ca44f3e45080dd7406"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5439ff450cc679ca44f3e45080dd7406">&#9670;&nbsp;</a></span>fprintHTML()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fprintHTML </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sxmlc_8h.html#a1423a22b82d292ebd77caf61c520cdce">SXML_CHAR</a> *&#160;</td>
          <td class="paramname"><em>str</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print a string to a file, transforming special characters into their HTML equivalent. </p>
<p>This is more efficient than a call to <code>fprintf(f, str2html(str))</code> as it does not need memory allocation; rather, it converts characters on-the-fly while writing. If <code>f</code> is NULL, does not print <code>str</code> but rather counts the number of characters that would be printed.</p>
<dl class="section return"><dt>Returns</dt><dd>the number of output characters. </dd></dl>

</div>
</div>
<a id="aa2934d246cfa7a2ceef8632d88d34fff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2934d246cfa7a2ceef8632d88d34fff">&#9670;&nbsp;</a></span>freadBOM()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sxmlc_8h.html#a0913f5fe1a761447a2a0dc3befe9d616">BOM_TYPE</a> freadBOM </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>bom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>sz_bom</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Detect a potential BOM at the current file position and read it into 'bom' (if not NULL, 'bom' should be at least 5 bytes). It also moves the 'f' beyond the BOM so it's possible to skip it by calling 'freadBOM(f, NULL, NULL)'. If no BOM is found, it leaves 'f' file pointer is reset to its original location. If not null, 'sz_bom' is filled with how many bytes are stored in 'bom'. Return the BOM type or BOM_NONE if none found (empty 'bom' in this case). </p>

</div>
</div>
<a id="a6b4e6316cf02c49046585daa9ff89af9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b4e6316cf02c49046585daa9ff89af9">&#9670;&nbsp;</a></span>has_html()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int has_html </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sxmlc_8h.html#a1423a22b82d292ebd77caf61c520cdce">SXML_CHAR</a> *&#160;</td>
          <td class="paramname"><em>html</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the given string contains HTML escape character (<code>&amp;</code>). </p>
<p>It can be useful to know whether <code><a class="el" href="sxmlc_8h.html#acfecfdb1904fbb7770e7fba2778bfa78" title="Replace occurrences of special HTML characters escape sequences (e.g. &quot;&amp;&quot;) by its character equivalen...">html2str()</a></code> would need to be called on <code>html</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">html</td><td>The string to check.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>false</code> if <code>html</code> does not contain the HTML escape character. </dd></dl>

</div>
</div>
<a id="acfecfdb1904fbb7770e7fba2778bfa78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfecfdb1904fbb7770e7fba2778bfa78">&#9670;&nbsp;</a></span>html2str()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sxmlc_8h.html#a1423a22b82d292ebd77caf61c520cdce">SXML_CHAR</a>* html2str </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sxmlc_8h.html#a1423a22b82d292ebd77caf61c520cdce">SXML_CHAR</a> *&#160;</td>
          <td class="paramname"><em>html</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sxmlc_8h.html#a1423a22b82d292ebd77caf61c520cdce">SXML_CHAR</a> *&#160;</td>
          <td class="paramname"><em>str</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace occurrences of special HTML characters escape sequences (e.g. <code>"&amp;amp;"</code>) by its character equivalent (e.g. <code>"&amp;"</code>). </p>
<p>If <code>html == str</code>, replacement is made in <code>str</code> itself, overwriting it. If <code>str</code> is <code>NULL</code>, replacement is made into <code>html</code>, overwriting it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">html</td><td>The string containing the HTML escapes (e.g. <code>"h&amp;ocirc;tel"</code>). </td></tr>
    <tr><td class="paramname">str</td><td>The string to receive the unescaped string (e.g. <code>"htel"</code>).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The unescaped string (<code>str</code>, or <code>html</code> if <code>str</code> was <code>NULL</code>). </dd></dl>

</div>
</div>
<a id="a964bbbfb2ebc796412fecd7aed243eb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a964bbbfb2ebc796412fecd7aed243eb6">&#9670;&nbsp;</a></span>read_line_alloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int read_line_alloc </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sxmlc_8h.html#a41734f8def67b21870b6fd8ceb153fb5">DataSourceType</a>&#160;</td>
          <td class="paramname"><em>in_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sxmlc_8h.html#a1423a22b82d292ebd77caf61c520cdce">SXML_CHAR</a> **&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>sz_line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sxmlc_8h.html#a1423a22b82d292ebd77caf61c520cdce">SXML_CHAR</a>&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sxmlc_8h.html#a1423a22b82d292ebd77caf61c520cdce">SXML_CHAR</a>&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>keep_fromto</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sxmlc_8h.html#a1423a22b82d292ebd77caf61c520cdce">SXML_CHAR</a>&#160;</td>
          <td class="paramname"><em>interest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>interest_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read a "line" from data source, eventually (re-)allocating a given buffer. A "line" is defined as a portion starting with character <code>from</code> (usually <code>&lt;</code>) ending at character <code>to</code> (usually <code>&gt;</code>). </p>
<p>Characters read will be stored in <code>line</code> starting at <code>i0</code> (this allows multiple calls to <code><a class="el" href="sxmlc_8h.html#a964bbbfb2ebc796412fecd7aed243eb6" title="Read a &quot;line&quot; from data source, eventually (re-)allocating a given buffer. A &quot;line&quot; is defined as a p...">read_line_alloc()</a></code> on the same <code>line</code> buffer without overwriting it at each call). Searches for character <code>from</code> until character <code>to</code>. If <code>from</code> is 0, starts from current position in the data source. If <code>to</code> is 0, it is replaced by <code>\n</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>The data source (either <code>FILE*</code> if <code>in_type</code> is <code>DATA_SOURCE_FILE</code> or <code>SXML_CHAR*</code> if <code>in_type</code> is <code>DATA_SOURCE_BUFFER</code>). </td></tr>
    <tr><td class="paramname">in_type</td><td>specifies the type of data source to be read. </td></tr>
    <tr><td class="paramname">line</td><td>can be <code>NULL</code>, in which case it will be allocated to <code>*sz_line</code> bytes. After the function returns, <code>*sz_line</code> is the actual buffer size. This allows multiple calls to this function using the same buffer (without re-allocating/freeing). </td></tr>
    <tr><td class="paramname">sz_line</td><td>is the size of the buffer <code>line</code> if previously allocated (in <code>SXML_CHAR</code>, not byte!). If <code>NULL</code> or 0, an internal value of <code>MEM_INCR_RLA</code> is used. </td></tr>
    <tr><td class="paramname">i0</td><td>The position where read characters are stored in <code>line</code>. </td></tr>
    <tr><td class="paramname">from</td><td>The character indicating a start of line. </td></tr>
    <tr><td class="paramname">to</td><td>The character indicating an end of line. </td></tr>
    <tr><td class="paramname">keep_fromto</td><td>if 0, removes characters <code>from</code> and <code>to</code> from the line (stripping). </td></tr>
    <tr><td class="paramname">interest</td><td>is a special character of interest, usually <code>\n</code> so we can count line numbers in the data source (valid only if <code>interest_count</code> is not <code>NULL</code>). </td></tr>
    <tr><td class="paramname">interest_count</td><td>if not <code>NULL</code>, will receive the count of <code>interest</code> characters while searching. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of characters in the line or 0 if an error occurred. </dd></dl>

</div>
</div>
<a id="a4d9dc791bef89eef2f2d463233c0d6b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d9dc791bef89eef2f2d463233c0d6b8">&#9670;&nbsp;</a></span>regstrcmp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int regstrcmp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sxmlc_8h.html#a1423a22b82d292ebd77caf61c520cdce">SXML_CHAR</a> *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sxmlc_8h.html#a1423a22b82d292ebd77caf61c520cdce">SXML_CHAR</a> *&#160;</td>
          <td class="paramname"><em>pattern</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks whether a string corresponds to a pattern. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to check. </td></tr>
    <tr><td class="paramname">pattern</td><td>can use wildcads such as <code>*</code> (any potentially empty string) or <code>?</code> (any character) and use <code>\</code> as an escape character. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> when <code>str</code> matches <code>pattern</code>, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="a0a18a78b9d6d2a64df6fa37305ab2048"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a18a78b9d6d2a64df6fa37305ab2048">&#9670;&nbsp;</a></span>SAX_Callbacks_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SAX_Callbacks_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sxmlc_8h.html#ad7a08824953657fdffaa58e3e23ad133">SAX_Callbacks</a> *&#160;</td>
          <td class="paramname"><em>sax</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper function to initialize all <code>sax</code> members to <code>NULL</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sax</td><td>The callbacks structure to initialize. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>false</code> is <code>sax</code> is NULL. </dd></dl>

</div>
</div>
<a id="a273e4ee4bf16ec891d82a3d0081550f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a273e4ee4bf16ec891d82a3d0081550f3">&#9670;&nbsp;</a></span>SAX_Callbacks_init_DOM()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SAX_Callbacks_init_DOM </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sxmlc_8h.html#ad7a08824953657fdffaa58e3e23ad133">SAX_Callbacks</a> *&#160;</td>
          <td class="paramname"><em>sax</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize <code>sax</code> with the "official" DOM callbacks. </p>

</div>
</div>
<a id="a15be9d3babba0d1e04cc13dfaba83cfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15be9d3babba0d1e04cc13dfaba83cfb">&#9670;&nbsp;</a></span>split_left_right()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int split_left_right </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sxmlc_8h.html#a1423a22b82d292ebd77caf61c520cdce">SXML_CHAR</a> *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sxmlc_8h.html#a1423a22b82d292ebd77caf61c520cdce">SXML_CHAR</a>&#160;</td>
          <td class="paramname"><em>sep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>l0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>l1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>i_sep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>r0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>r1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ignore_spaces</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ignore_quotes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Split a string into a left and right part around a given separator. </p>
<p>The beginning and end indices of left part are stored in <code>l0</code> and <code>l1</code> while the right part's are stored in <code>r0</code> and <code>r1</code>. The separator position is stored at <code>i_sep</code> (whenever these are not <code>NULL</code>). Whenever the right member is empty (e.g. <code>"attrib"</code> or <code>"attrib="</code>), <code>*r0</code> is set to <code>strlen(str)</code> and <code>*r1</code> to <code>*r0-1</code> (crossed).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to split. </td></tr>
    <tr><td class="paramname">sep</td><td>The separator (e.g. <code>=</code>). </td></tr>
    <tr><td class="paramname">l0</td><td>will contain the index of the left part first character in <code>str</code>. </td></tr>
    <tr><td class="paramname">l1</td><td>will contain the index of left part last character in <code>str</code>. </td></tr>
    <tr><td class="paramname">i_sep</td><td>will contain the index of the separator in <code>str</code>, or -1 if not found. </td></tr>
    <tr><td class="paramname">r0</td><td>will contain the index of the left part first character in <code>str</code>. </td></tr>
    <tr><td class="paramname">r1</td><td>will contain the index of left part last character in <code>str</code>. </td></tr>
    <tr><td class="paramname">ignore_spaces</td><td>Is <code>true</code>, computed indexes will not take into account potential spaces around the separator as well as before left part and after right part, so <code>&quot;name=val&quot;</code> will be equivalent to <code>&quot;name = val&quot;</code>. </td></tr>
    <tr><td class="paramname">ignore_quotes</td><td>If <code>true</code>, quotes (<code>&quot;</code> or <code>'</code>) will not be taken into account when parsing left and right members, so &lsquo;&quot;name = 'val&rsquo;&quot;<code>will be equivalent to</code>&quot;name = val&quot;`.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>false</code> when <code>str</code> is malformed, <code>true</code> when splitting was successful. </dd></dl>

</div>
</div>
<a id="ac87b7e66127a27a127395aa46010c601"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac87b7e66127a27a127395aa46010c601">&#9670;&nbsp;</a></span>str2html()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sxmlc_8h.html#a1423a22b82d292ebd77caf61c520cdce">SXML_CHAR</a>* str2html </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sxmlc_8h.html#a1423a22b82d292ebd77caf61c520cdce">SXML_CHAR</a> *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sxmlc_8h.html#a1423a22b82d292ebd77caf61c520cdce">SXML_CHAR</a> *&#160;</td>
          <td class="paramname"><em>html</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace occurrences of special characters (e.g. <code>&amp;</code>) into their XML escaped equivalent (e.g. <code>"&amp;amp;"</code>). </p>
<p><code>html</code> is supposed allocated to the correct size (e.g. using <code>__malloc(strlen_html(str)+30)</code>) and <em>different</em> from <code>str</code> (unlike <code><a class="el" href="sxmlc_8h.html#acfecfdb1904fbb7770e7fba2778bfa78" title="Replace occurrences of special HTML characters escape sequences (e.g. &quot;&amp;&quot;) by its character equivalen...">html2str()</a></code>), as the string will expand. If it is <code>NULL</code>, <code>str</code> will be analyzed and a string will be allocated to the exact size and returned. In that case, it is the responsibility of the caller to <code>free()</code> the result! </p><dl class="section return"><dt>Returns</dt><dd><code>html</code>, or <code>NULL</code> if <code>str</code> or <code>html</code> are <code>NULL</code>, or when <code>html</code> is <code>str</code>. </dd></dl>

</div>
</div>
<a id="a72c65b1ce14f2a5f472cae742d2cfc54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72c65b1ce14f2a5f472cae742d2cfc54">&#9670;&nbsp;</a></span>str_unescape()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sxmlc_8h.html#a1423a22b82d292ebd77caf61c520cdce">SXML_CHAR</a>* str_unescape </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sxmlc_8h.html#a1423a22b82d292ebd77caf61c520cdce">SXML_CHAR</a> *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove <code>\</code> characters from <code>str</code>, modifying it. </p>
<dl class="section return"><dt>Returns</dt><dd><code>str</code> unescaped. </dd></dl>

</div>
</div>
<a id="a6b0d9802839e6529a7212a631cb2d2d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b0d9802839e6529a7212a631cb2d2d8">&#9670;&nbsp;</a></span>strcat_alloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sxmlc_8h.html#a1423a22b82d292ebd77caf61c520cdce">SXML_CHAR</a>* strcat_alloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sxmlc_8h.html#a1423a22b82d292ebd77caf61c520cdce">SXML_CHAR</a> **&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="sxmlc_8h.html#a1423a22b82d292ebd77caf61c520cdce">SXML_CHAR</a> *&#160;</td>
          <td class="paramname"><em>src2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Concatenates the string pointed at by <code>src1</code> with <code>src2</code> into <code>*src1</code> and return it. </p>
<dl class="section return"><dt>Returns</dt><dd><code>*src1</code>, or <code>NULL</code> if out of memory. </dd></dl>

</div>
</div>
<a id="a7de2f042b023b40a9961f8453a2efee9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7de2f042b023b40a9961f8453a2efee9">&#9670;&nbsp;</a></span>strip_spaces()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sxmlc_8h.html#a1423a22b82d292ebd77caf61c520cdce">SXML_CHAR</a>* strip_spaces </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sxmlc_8h.html#a1423a22b82d292ebd77caf61c520cdce">SXML_CHAR</a> *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sxmlc_8h.html#a1423a22b82d292ebd77caf61c520cdce">SXML_CHAR</a>&#160;</td>
          <td class="paramname"><em>repl_sq</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Strip whitespaces at the beginning and end of a string, modifying it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to strip. </td></tr>
    <tr><td class="paramname">repl_sq</td><td>if not null, squeezes spaces to an single character <code>repl_sq</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the stripped string, which can be <code>str</code> directly if there are no whitespaces at the beginning. N.B. that if <code>str</code> was allocated, it should be freed later, <em>not</em> the returned reference. </dd></dl>

</div>
</div>
<a id="a09f4a29baaef565145cfa0134b00a4c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09f4a29baaef565145cfa0134b00a4c9">&#9670;&nbsp;</a></span>strlen_html()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int strlen_html </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sxmlc_8h.html#a1423a22b82d292ebd77caf61c520cdce">SXML_CHAR</a> *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the length of a string as if all its special character were replaced by their HTML escapes. </p>
<dl class="section return"><dt>Returns</dt><dd>0 if <code>str</code> is NULL. </dd></dl>

</div>
</div>
<a id="ae46d39157e315e7f2a41c1b5bae8400d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae46d39157e315e7f2a41c1b5bae8400d">&#9670;&nbsp;</a></span>XML_get_nb_registered_user_tags()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XML_get_nb_registered_user_tags </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of user-defined tags. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of registered tags. </dd></dl>

</div>
</div>
<a id="aa925dc88370022fe7112fa2c4a7de732"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa925dc88370022fe7112fa2c4a7de732">&#9670;&nbsp;</a></span>XML_get_registered_user_tag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XML_get_registered_user_tag </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sxmlc_8h.html#ae5087224fc7c4f0dfabdd3ead8c91551">TagType</a>&#160;</td>
          <td class="paramname"><em>tag_type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Search for a user tag based on it type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tag_type</td><td>The tag type, as given in <code><a class="el" href="sxmlc_8h.html#a275a539b72263e0950ba2475f77b05ba" title="Register an XML tag, giving its &#39;start&#39; and &#39;end&#39; string, which should include &#39;&lt;&#39; and &#39;&gt;&#39;.">XML_register_user_tag()</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the index of first occurrence of 'tag_type' in registered user tags, or '-1' if not found. </dd></dl>

</div>
</div>
<a id="ad60acb82ff12a2142cff3ce43b02ed56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad60acb82ff12a2142cff3ce43b02ed56">&#9670;&nbsp;</a></span>XML_parse_1string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sxmlc_8h.html#ae5087224fc7c4f0dfabdd3ead8c91551">TagType</a> XML_parse_1string </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="sxmlc_8h.html#a1423a22b82d292ebd77caf61c520cdce">SXML_CHAR</a> *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sxmlc_8h.html#a2f1120f1eef3bddf7316ed256c0a36a8">XMLNode</a> *&#160;</td>
          <td class="paramname"><em>xmlnode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a string that is supposed to be an xml tag like <code>&lt;tag (attribName="attribValue")* [/]&gt;</code> or <code>&lt;/tag&gt;</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to parse. </td></tr>
    <tr><td class="paramname">xmlnode</td><td>the <code>XMLNode</code> structure which tag name and attributes will be filled. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if an error occurred (malformed <code>str</code> or memory). <code>TAG_*</code> when string is recognized. </dd></dl>

</div>
</div>
<a id="a7552ee06f68e1d6222f68f84921c8017"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7552ee06f68e1d6222f68f84921c8017">&#9670;&nbsp;</a></span>XML_parse_attribute_to()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XML_parse_attribute_to </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="sxmlc_8h.html#a1423a22b82d292ebd77caf61c520cdce">SXML_CHAR</a> *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sxmlc_8h.html#a195d94c80e0524f308039447aea2e8e9">XMLAttribute</a> *&#160;</td>
          <td class="paramname"><em>xmlattr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse an attribute to an <code>XMLAttribute</code> struct. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>contains the string to parse, supposed like <code>attrName[ ]=[ ]["]attr Value["]</code>. </td></tr>
    <tr><td class="paramname">to</td><td>is the position in <code>str</code> to stop at, or <code>-1</code> to parse until the end of <code>str</code>. </td></tr>
    <tr><td class="paramname">xmlattr</td><td>filled with <code>xmlattr-&gt;name</code> to <code>attrName</code> and <code>xmlattr-&gt;value</code> to <code>attr Value</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if not enough memory or bad parameters (<code>str</code> or <code>xmlattr</code> is <code>NULL</code>), 2 if last quote is missing in the attribute value, 1 if <code>xmlattr</code> was filled correctly. </dd></dl>

</div>
</div>
<a id="a275a539b72263e0950ba2475f77b05ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a275a539b72263e0950ba2475f77b05ba">&#9670;&nbsp;</a></span>XML_register_user_tag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XML_register_user_tag </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sxmlc_8h.html#ae5087224fc7c4f0dfabdd3ead8c91551">TagType</a>&#160;</td>
          <td class="paramname"><em>tag_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sxmlc_8h.html#a1423a22b82d292ebd77caf61c520cdce">SXML_CHAR</a> *&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sxmlc_8h.html#a1423a22b82d292ebd77caf61c520cdce">SXML_CHAR</a> *&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register an XML tag, giving its 'start' and 'end' string, which should include '&lt;' and '&gt;'. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tag_type</td><td>is user-given and has to be less than or equal to <code>TAG_USER</code>. It will be returned as the <code>tag_type</code> member of the <code>XMLNode</code> struct. <em>Note that no test is performed to check for an already-existing <code>tag_type</code></em>. </td></tr>
    <tr><td class="paramname">start</td><td>The start string used to detect such tag (e.g. <code>"&lt;![CDATA["</code>). Should start with <code>&lt;</code>. </td></tr>
    <tr><td class="paramname">end</td><td>The tag end string (e.g. <code>"]]&gt;"</code>). Should end with <code>&gt;</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>tag index in user tags table when successful, or -1 if the <code>tag_type</code> is invalid or the new tag could not be registered (e.g. when <code>start</code> does not start with <code>&lt;</code> or <code>end</code> does not end with <code>&gt;</code>). </dd></dl>

</div>
</div>
<a id="a6ca0e0326bcae96bbcf8f5b24a9a184d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ca0e0326bcae96bbcf8f5b24a9a184d">&#9670;&nbsp;</a></span>XML_unregister_user_tag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XML_unregister_user_tag </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i_tag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove a registered user tag. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i_tag</td><td>The user-tag number, as returned by <code><a class="el" href="sxmlc_8h.html#a275a539b72263e0950ba2475f77b05ba" title="Register an XML tag, giving its &#39;start&#39; and &#39;end&#39; string, which should include &#39;&lt;&#39; and &#39;&gt;&#39;.">XML_register_user_tag()</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the new number of registered user tags or -1 if <code>i_tag</code> is invalid. </dd></dl>

</div>
</div>
<a id="a7dec7705c5543e70c8a59817570e689f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7dec7705c5543e70c8a59817570e689f">&#9670;&nbsp;</a></span>XMLDoc_add_node()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XMLDoc_add_node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sxmlc_8h.html#a4bf9d6033001ea055d09b23d31a6ba64">XMLDoc</a> *&#160;</td>
          <td class="paramname"><em>doc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sxmlc_8h.html#a2f1120f1eef3bddf7316ed256c0a36a8">XMLNode</a> *&#160;</td>
          <td class="paramname"><em>node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a node to the document. </p>
<p>If the node type is <code>TAG_FATHER</code>, it also sets the document root node if previously undefined. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">doc</td><td>The document. </td></tr>
    <tr><td class="paramname">node</td><td>The node to add. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the node index, or -1 for uninitialized <code>doc</code> or <code>node</code>, or memory error. </dd></dl>

</div>
</div>
<a id="a398101d26edb8022fdf7ab884875975c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a398101d26edb8022fdf7ab884875975c">&#9670;&nbsp;</a></span>XMLDoc_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XMLDoc_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sxmlc_8h.html#a4bf9d6033001ea055d09b23d31a6ba64">XMLDoc</a> *&#160;</td>
          <td class="paramname"><em>doc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free an XML document, including all of its nodes, recursively. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">doc</td><td>The document to initialize. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>false</code> if <code>doc</code> was not initialized. </dd></dl>

</div>
</div>
<a id="a21a1e3e99b13c66552d6cac05d64426c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21a1e3e99b13c66552d6cac05d64426c">&#9670;&nbsp;</a></span>XMLDoc_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XMLDoc_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sxmlc_8h.html#a4bf9d6033001ea055d09b23d31a6ba64">XMLDoc</a> *&#160;</td>
          <td class="paramname"><em>doc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes an already-allocated XML document. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">doc</td><td>The document to initialize. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>false</code> if <code>doc</code> is NULL. </dd></dl>

</div>
</div>
<a id="ada0f9853892402f894957e946878cb09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada0f9853892402f894957e946878cb09">&#9670;&nbsp;</a></span>XMLDoc_parse_buffer_DOM_text_as_nodes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XMLDoc_parse_buffer_DOM_text_as_nodes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="sxmlc_8h.html#a1423a22b82d292ebd77caf61c520cdce">SXML_CHAR</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="sxmlc_8h.html#a1423a22b82d292ebd77caf61c520cdce">SXML_CHAR</a> *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sxmlc_8h.html#a4bf9d6033001ea055d09b23d31a6ba64">XMLDoc</a> *&#160;</td>
          <td class="paramname"><em>doc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>text_as_nodes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse a memory buffer into an initialized document (DOM mode). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The memory buffer to parse. </td></tr>
    <tr><td class="paramname">name</td><td>The buffer name (to identify several buffers if run concurrently). </td></tr>
    <tr><td class="paramname">doc</td><td>The document to parse into. </td></tr>
    <tr><td class="paramname">text_as_nodes</td><td>should be non-zero to put text into separate TAG_TEXT nodes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>false</code> in case of error (memory or unavailable filename, malformed document), <code>true</code> otherwise. </dd></dl>

</div>
</div>
<a id="a51bca4f7f1fd4957b1367ad0e1882e9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51bca4f7f1fd4957b1367ad0e1882e9d">&#9670;&nbsp;</a></span>XMLDoc_parse_buffer_SAX_len()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XMLDoc_parse_buffer_SAX_len </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="sxmlc_8h.html#a1423a22b82d292ebd77caf61c520cdce">SXML_CHAR</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>buffer_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="sxmlc_8h.html#a1423a22b82d292ebd77caf61c520cdce">SXML_CHAR</a> *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="sxmlc_8h.html#ad7a08824953657fdffaa58e3e23ad133">SAX_Callbacks</a> *&#160;</td>
          <td class="paramname"><em>sax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse an XML buffer, calling SAX callbacks. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The memory buffer to parse. </td></tr>
    <tr><td class="paramname">buffer_len</td><td>The buffer lenght, in <em>characters</em> (i.e. can be 2 bytes in unicode). </td></tr>
    <tr><td class="paramname">name</td><td>An optional buffer name. </td></tr>
    <tr><td class="paramname">sax</td><td>The SAX callbacks that will be called by the parser on each XML event. </td></tr>
    <tr><td class="paramname">user</td><td>A user-given pointer that will be given back to all callbacks. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>false</code> in case of error (memory or unavailable filename, malformed document) or when requested by a SAX callback. <code>true</code> otherwise. </dd></dl>

</div>
</div>
<a id="ae64f70bcc3133a9542c7d05d65bc2602"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae64f70bcc3133a9542c7d05d65bc2602">&#9670;&nbsp;</a></span>XMLDoc_parse_file_DOM_text_as_nodes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XMLDoc_parse_file_DOM_text_as_nodes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="sxmlc_8h.html#a1423a22b82d292ebd77caf61c520cdce">SXML_CHAR</a> *&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sxmlc_8h.html#a4bf9d6033001ea055d09b23d31a6ba64">XMLDoc</a> *&#160;</td>
          <td class="paramname"><em>doc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>text_as_nodes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse a file into an initialized XML document (DOM mode). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>The file to parse. </td></tr>
    <tr><td class="paramname">doc</td><td>The document to parse into. </td></tr>
    <tr><td class="paramname">text_as_nodes</td><td>should be non-zero to put text into separate TAG_TEXT nodes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>false</code> in case of error (memory or unavailable filename, malformed document), <code>true</code> otherwise. </dd></dl>

</div>
</div>
<a id="a4771d1652213454ede544a5d63c1f916"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4771d1652213454ede544a5d63c1f916">&#9670;&nbsp;</a></span>XMLDoc_parse_file_SAX()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XMLDoc_parse_file_SAX </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="sxmlc_8h.html#a1423a22b82d292ebd77caf61c520cdce">SXML_CHAR</a> *&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="sxmlc_8h.html#ad7a08824953657fdffaa58e3e23ad133">SAX_Callbacks</a> *&#160;</td>
          <td class="paramname"><em>sax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse an XML file, calling SAX callbacks. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>The file to parse. </td></tr>
    <tr><td class="paramname">sax</td><td>The SAX callbacks that will be called by the parser on each XML event. </td></tr>
    <tr><td class="paramname">user</td><td>A user-given pointer that will be given back to all callbacks. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>false</code> in case of error (memory or unavailable filename, malformed document) or when requested by a SAX callback. <code>true</code> otherwise. </dd></dl>

</div>
</div>
<a id="a5b5dd76b23961f168296460abeb58bff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b5dd76b23961f168296460abeb58bff">&#9670;&nbsp;</a></span>XMLDoc_print_attr_sep()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XMLDoc_print_attr_sep </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="sxmlc_8h.html#a4bf9d6033001ea055d09b23d31a6ba64">XMLDoc</a> *&#160;</td>
          <td class="paramname"><em>doc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="sxmlc_8h.html#a1423a22b82d292ebd77caf61c520cdce">SXML_CHAR</a> *&#160;</td>
          <td class="paramname"><em>tag_sep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="sxmlc_8h.html#a1423a22b82d292ebd77caf61c520cdce">SXML_CHAR</a> *&#160;</td>
          <td class="paramname"><em>child_sep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="sxmlc_8h.html#a1423a22b82d292ebd77caf61c520cdce">SXML_CHAR</a> *&#160;</td>
          <td class="paramname"><em>attr_sep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>keep_text_spaces</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sz_line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nb_char_tab</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints the XML document using <code><a class="el" href="sxmlc_8h.html#a9613d008088e8f02f49f30baf670e19f" title="Print the node and its children to a file (that can be stdout).">XMLNode_print_attr_sep()</a></code> on all document nodes. </p>

</div>
</div>
<a id="a742fd7c60f31ec6aea0412b5fa7fcf03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a742fd7c60f31ec6aea0412b5fa7fcf03">&#9670;&nbsp;</a></span>XMLDoc_remove_node()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XMLDoc_remove_node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sxmlc_8h.html#a4bf9d6033001ea055d09b23d31a6ba64">XMLDoc</a> *&#160;</td>
          <td class="paramname"><em>doc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>free_node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove a node from the document root nodes. Inactive nodes can be removed like this. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">doc</td><td>The XML document. </td></tr>
    <tr><td class="paramname">i_node</td><td>The node index to remove </td></tr>
    <tr><td class="paramname">free_node</td><td>if <code>true</code>, free the node itself. This parameter is usually <code>true</code> but should be 'false' when the node is a pointer to local or global variable instead of user-allocated memory. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if node was removed or <code>false</code> if <code>doc</code> or <code>i_node</code> is invalid. </dd></dl>

</div>
</div>
<a id="a3236154594afe2bf16076aa82b610c81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3236154594afe2bf16076aa82b610c81">&#9670;&nbsp;</a></span>XMLDoc_set_root()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XMLDoc_set_root </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sxmlc_8h.html#a4bf9d6033001ea055d09b23d31a6ba64">XMLDoc</a> *&#160;</td>
          <td class="paramname"><em>doc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i_root</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the new document root node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">doc</td><td>The document to initialize. </td></tr>
    <tr><td class="paramname">i_root</td><td>The element index to set as root. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>false</code> if <code>doc</code> is not initialized or <code>i_root</code> is invalid, <code>true</code> otherwise. </dd></dl>

</div>
</div>
<a id="a95015ebeffaec2d9f7c091c3ec50ba03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95015ebeffaec2d9f7c091c3ec50ba03">&#9670;&nbsp;</a></span>XMLNode_add_child()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XMLNode_add_child </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sxmlc_8h.html#a2f1120f1eef3bddf7316ed256c0a36a8">XMLNode</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sxmlc_8h.html#a2f1120f1eef3bddf7316ed256c0a36a8">XMLNode</a> *&#160;</td>
          <td class="paramname"><em>child</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a child to a node. </p>
<dl class="section return"><dt>Returns</dt><dd><code>false</code> for memory problem, <code>true</code> otherwise. </dd></dl>

</div>
</div>
<a id="a20bcb360b343439e18f4fcdc15c4b9f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20bcb360b343439e18f4fcdc15c4b9f3">&#9670;&nbsp;</a></span>XMLNode_allocN()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sxmlc_8h.html#a2f1120f1eef3bddf7316ed256c0a36a8">XMLNode</a>* XMLNode_allocN </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate and initialize XML nodes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>is the number of contiguous elements to allocate (to create and array). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>NULL</code> if not enough memory, or the pointer to the elements otherwise. </dd></dl>

</div>
</div>
<a id="aea53555f44a7b82bafbe9e174d32a42c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea53555f44a7b82bafbe9e174d32a42c">&#9670;&nbsp;</a></span>XMLNode_copy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XMLNode_copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sxmlc_8h.html#a2f1120f1eef3bddf7316ed256c0a36a8">XMLNode</a> *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="sxmlc_8h.html#a2f1120f1eef3bddf7316ed256c0a36a8">XMLNode</a> *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>copy_children</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy a node to another one, optionally including its children. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dst</td><td>The node receiving the copy. N.B. thtat the node is freed first! </td></tr>
    <tr><td class="paramname">src</td><td>The node to duplicate. If <code>NULL</code>, <code>dst</code> is freed and initialized. </td></tr>
    <tr><td class="paramname">copy_children</td><td><code>true</code> to include <code>src</code> children (recursive copy). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>false</code> in case of memory error or if <code>dst</code> is <code>NULL</code> or <code>src</code> uninitialized. </dd></dl>

</div>
</div>
<a id="ac36bd02ca8769b16af03fc527dcb4ffb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac36bd02ca8769b16af03fc527dcb4ffb">&#9670;&nbsp;</a></span>XMLNode_dup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sxmlc_8h.html#a2f1120f1eef3bddf7316ed256c0a36a8">XMLNode</a>* XMLNode_dup </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="sxmlc_8h.html#a2f1120f1eef3bddf7316ed256c0a36a8">XMLNode</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>copy_children</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Duplicate a node, potentially with its children. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>The node to duplicate. </td></tr>
    <tr><td class="paramname">copy_children</td><td><code>true</code> to include <code>src</code> children (recursive copy). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>NULL</code> if not enough memory, or a pointer to the new node otherwise. </dd></dl>

</div>
</div>
<a id="aa69f4b2b3ab62eb026d1fe4c231be2c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa69f4b2b3ab62eb026d1fe4c231be2c0">&#9670;&nbsp;</a></span>XMLNode_equal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XMLNode_equal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="sxmlc_8h.html#a2f1120f1eef3bddf7316ed256c0a36a8">XMLNode</a> *&#160;</td>
          <td class="paramname"><em>node1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="sxmlc_8h.html#a2f1120f1eef3bddf7316ed256c0a36a8">XMLNode</a> *&#160;</td>
          <td class="paramname"><em>node2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node1</td><td>The first node to test. </td></tr>
    <tr><td class="paramname">node2</td><td>The second node to test. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <code>node1</code> is the same as <code>node2</code> (i.e. same tag, same active attributes) but <em>not necessarily</em> the same children. </dd></dl>

</div>
</div>
<a id="a644c2517909786a6070de35ac52c977e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a644c2517909786a6070de35ac52c977e">&#9670;&nbsp;</a></span>XMLNode_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XMLNode_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sxmlc_8h.html#a2f1120f1eef3bddf7316ed256c0a36a8">XMLNode</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free a node and all its children. </p>

</div>
</div>
<a id="a781ed297ac9cadf8ba6cd60b328b1589"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a781ed297ac9cadf8ba6cd60b328b1589">&#9670;&nbsp;</a></span>XMLNode_get_attribute_count()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XMLNode_get_attribute_count </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="sxmlc_8h.html#a2f1120f1eef3bddf7316ed256c0a36a8">XMLNode</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the number of active attributes of 'node', or '-1' if 'node' is invalid. </dd></dl>

</div>
</div>
<a id="a6df62789db1b726caaae280230570baa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6df62789db1b726caaae280230570baa">&#9670;&nbsp;</a></span>XMLNode_get_attribute_with_default()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XMLNode_get_attribute_with_default </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sxmlc_8h.html#a2f1120f1eef3bddf7316ed256c0a36a8">XMLNode</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="sxmlc_8h.html#a1423a22b82d292ebd77caf61c520cdce">SXML_CHAR</a> *&#160;</td>
          <td class="paramname"><em>attr_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="sxmlc_8h.html#a1423a22b82d292ebd77caf61c520cdce">SXML_CHAR</a> **&#160;</td>
          <td class="paramname"><em>attr_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="sxmlc_8h.html#a1423a22b82d292ebd77caf61c520cdce">SXML_CHAR</a> *&#160;</td>
          <td class="paramname"><em>default_attr_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve an attribute value, based on its name, returning a default value if the attribute does not exist. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>The node. </td></tr>
    <tr><td class="paramname">attr_name</td><td>The attribute name to search. </td></tr>
    <tr><td class="paramname">attr_value</td><td>A pointer receiving a <em>copy</em> of the attribute value (from <code>strdup()</code>). </td></tr>
    <tr><td class="paramname">default_attr_value</td><td>If <code>attr_name</code> does not exist in <code>node</code>, a <em>copy</em> (from <code>strdup()</code>) of this string will be stored in <code>attr_value</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>false</code> when the <code>node</code> is invalid, <code>attr_name</code> is NULL or empty, or <code>attr_value</code> is NULL. </dd></dl>

</div>
</div>
<a id="a84df156c286a932be44a5a86b00f5fbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84df156c286a932be44a5a86b00f5fbf">&#9670;&nbsp;</a></span>XMLNode_get_child()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sxmlc_8h.html#a2f1120f1eef3bddf7316ed256c0a36a8">XMLNode</a>* XMLNode_get_child </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="sxmlc_8h.html#a2f1120f1eef3bddf7316ed256c0a36a8">XMLNode</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i_child</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get an <em>active</em> node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>The node. </td></tr>
    <tr><td class="paramname">i_child</td><td>The active node index to retrieve. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <code>i_child</code>th <em>active</em> node. </dd></dl>

</div>
</div>
<a id="a3685d42addf2e84938b99e9874a99c44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3685d42addf2e84938b99e9874a99c44">&#9670;&nbsp;</a></span>XMLNode_get_children_count()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XMLNode_get_children_count </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="sxmlc_8h.html#a2f1120f1eef3bddf7316ed256c0a36a8">XMLNode</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of <em>active</em> children of a node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>The node. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of active children nodes of <code>node</code>, or -1 if <code>node</code> is invalid. N.B. that it can be different from <code>node-&gt;n_children</code> if some nodes are deactivated! </dd></dl>

</div>
</div>
<a id="a164ce1cb11ba3d5776a4974897dd6478"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a164ce1cb11ba3d5776a4974897dd6478">&#9670;&nbsp;</a></span>XMLNode_get_index()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XMLNode_get_index </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="sxmlc_8h.html#a2f1120f1eef3bddf7316ed256c0a36a8">XMLNode</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the node position among its <em>active</em> siblings. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>The node. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>node</code> position among its siblings, -1 if <code>node</code> is invalid or -2 if <code>node</code> could not be found in its father's children (in which case I'd appreciate a bug report with the XML and steps that led to that situation!). </dd></dl>

</div>
</div>
<a id="a6707d1bb0e09196b21644e4d5b60663b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6707d1bb0e09196b21644e4d5b60663b">&#9670;&nbsp;</a></span>XMLNode_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XMLNode_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sxmlc_8h.html#a2f1120f1eef3bddf7316ed256c0a36a8">XMLNode</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize an already-allocated XMLNode. </p>

</div>
</div>
<a id="adbe870babf239d4c2c0f6c38947fdb3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbe870babf239d4c2c0f6c38947fdb3f">&#9670;&nbsp;</a></span>XMLNode_insert_child()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XMLNode_insert_child </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sxmlc_8h.html#a2f1120f1eef3bddf7316ed256c0a36a8">XMLNode</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sxmlc_8h.html#a2f1120f1eef3bddf7316ed256c0a36a8">XMLNode</a> *&#160;</td>
          <td class="paramname"><em>child</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert a node at a given position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>The node to which inserting the child node. </td></tr>
    <tr><td class="paramname">child</td><td>The node to insert. </td></tr>
    <tr><td class="paramname">index</td><td>The insert position: if <code>index &lt;= 0</code>: will be the first child (0). If <code>index &gt;= child-&gt;father-&gt;n_children</code>: will be the last child. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>'false' if 'node' is not initialized, 'true' otherwise. </dd></dl>

</div>
</div>
<a id="a942aba2075bd42e2b5187f28116bd3ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a942aba2075bd42e2b5187f28116bd3ed">&#9670;&nbsp;</a></span>XMLNode_move_child()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XMLNode_move_child </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sxmlc_8h.html#a2f1120f1eef3bddf7316ed256c0a36a8">XMLNode</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Move a child node among its siblings. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>The node which children should be moved. </td></tr>
    <tr><td class="paramname">from</td><td>Position of the node to move. </td></tr>
    <tr><td class="paramname">to</td><td>Position to move to. Moved to first position if <code>to &lt;= 0</code> or last position if <code>to &gt;= node-&gt;n_children</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>false</code> if <code>node</code> is not initialized or <code>from</code> is invalid. <code>true</code> otherwise. </dd></dl>

</div>
</div>
<a id="a7ff8567100a02c6f9d6f8cacc00e8450"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ff8567100a02c6f9d6f8cacc00e8450">&#9670;&nbsp;</a></span>XMLNode_new()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sxmlc_8h.html#a2f1120f1eef3bddf7316ed256c0a36a8">XMLNode</a>* XMLNode_new </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="sxmlc_8h.html#ae5087224fc7c4f0dfabdd3ead8c91551">TagType</a>&#160;</td>
          <td class="paramname"><em>tag_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="sxmlc_8h.html#a1423a22b82d292ebd77caf61c520cdce">SXML_CHAR</a> *&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="sxmlc_8h.html#a1423a22b82d292ebd77caf61c520cdce">SXML_CHAR</a> *&#160;</td>
          <td class="paramname"><em>text</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate and initialize a new <code>XMLNode</code> of the given type, tag name and text. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tag_type</td><td>The node tag type. </td></tr>
    <tr><td class="paramname">tag</td><td>The node tag. </td></tr>
    <tr><td class="paramname">text</td><td>The node text. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>NULL</code> if not enough memory, or the pointer to the node otherwise. </dd></dl>

</div>
</div>
<a id="a8ab1c34dac599dd896015f6cd9dbc7ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ab1c34dac599dd896015f6cd9dbc7ef">&#9670;&nbsp;</a></span>XMLNode_next()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sxmlc_8h.html#a2f1120f1eef3bddf7316ed256c0a36a8">XMLNode</a>* XMLNode_next </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="sxmlc_8h.html#a2f1120f1eef3bddf7316ed256c0a36a8">XMLNode</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the "next" node: first child (if any) of next sibling otherwise. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>The node. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the next node in XML order, or <code>NULL</code> if <code>node</code> is invalid or the last node. </dd></dl>

</div>
</div>
<a id="a1564a1392d83360ac1a43d8f931bee13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1564a1392d83360ac1a43d8f931bee13">&#9670;&nbsp;</a></span>XMLNode_next_sibling()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sxmlc_8h.html#a2f1120f1eef3bddf7316ed256c0a36a8">XMLNode</a>* XMLNode_next_sibling </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="sxmlc_8h.html#a2f1120f1eef3bddf7316ed256c0a36a8">XMLNode</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the next sibling node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>The node which sibling to retrieve. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the next sibling of the node, or <code>NULL</code> if <code>node</code> is invalid or the last child or if its father could not be determined (i.e. <code>node</code> is a root node). </dd></dl>

</div>
</div>
<a id="a9613d008088e8f02f49f30baf670e19f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9613d008088e8f02f49f30baf670e19f">&#9670;&nbsp;</a></span>XMLNode_print_attr_sep()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XMLNode_print_attr_sep </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="sxmlc_8h.html#a2f1120f1eef3bddf7316ed256c0a36a8">XMLNode</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="sxmlc_8h.html#a1423a22b82d292ebd77caf61c520cdce">SXML_CHAR</a> *&#160;</td>
          <td class="paramname"><em>tag_sep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="sxmlc_8h.html#a1423a22b82d292ebd77caf61c520cdce">SXML_CHAR</a> *&#160;</td>
          <td class="paramname"><em>child_sep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="sxmlc_8h.html#a1423a22b82d292ebd77caf61c520cdce">SXML_CHAR</a> *&#160;</td>
          <td class="paramname"><em>attr_sep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>keep_text_spaces</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sz_line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nb_char_tab</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print the node and its children to a file (that can be <code>stdout</code>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>The node to print. </td></tr>
    <tr><td class="paramname">f</td><td>The file to print to (can be <code>stdout</code>). </td></tr>
    <tr><td class="paramname">tag_sep</td><td>The string to use to separate nodes from each other (usually <code>"\n"</code>). </td></tr>
    <tr><td class="paramname">child_sep</td><td>The additional string to put for each child level (usually <code>"\t"</code>). </td></tr>
    <tr><td class="paramname">attr_sep</td><td>The additional string to put to separate attributes (usually <code>" "</code>). </td></tr>
    <tr><td class="paramname">keep_text_spaces</td><td>indicates that text should not be printed if it is composed of spaces, tabs or new lines only (e.g. when XML document spans on several lines due to pretty-printing). </td></tr>
    <tr><td class="paramname">sz_line</td><td>The maximum number of characters that can be put on a single line. The node remainder will be output to extra lines. </td></tr>
    <tr><td class="paramname">nb_char_tab</td><td>How many characters should be counted for a tab when counting characters in the line. It usually is 8 or 4, but at least 1. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>false</code> on invalid arguments (<code>NULL</code> <code>node</code> or <code>f</code>), <code>true</code> otherwise. </dd></dl>

</div>
</div>
<a id="a4683e10b0452f1fc9e7d961e0557a50c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4683e10b0452f1fc9e7d961e0557a50c">&#9670;&nbsp;</a></span>XMLNode_print_header()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XMLNode_print_header </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="sxmlc_8h.html#a2f1120f1eef3bddf7316ed256c0a36a8">XMLNode</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sz_line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nb_char_tab</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print the node "header": <code>&lt;tagname attribname="attibval" ...[/]&gt;</code>, spanning it on several lines if needed. </p>
<dl class="section return"><dt>Returns</dt><dd><code>false</code> on invalid arguments (<code>NULL</code> <code>node</code> or <code>f</code>), <code>true</code> otherwise. </dd></dl>

</div>
</div>
<a id="a20aae5ac5789340ebc82c0f50ca5fa3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20aae5ac5789340ebc82c0f50ca5fa3e">&#9670;&nbsp;</a></span>XMLNode_remove_all_attributes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XMLNode_remove_all_attributes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sxmlc_8h.html#a2f1120f1eef3bddf7316ed256c0a36a8">XMLNode</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove all attributes from <code>node</code>. </p>

</div>
</div>
<a id="ab3ceb2fb162c58ad3131cd7296d49d8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3ceb2fb162c58ad3131cd7296d49d8c">&#9670;&nbsp;</a></span>XMLNode_remove_attribute()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XMLNode_remove_attribute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sxmlc_8h.html#a2f1120f1eef3bddf7316ed256c0a36a8">XMLNode</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i_attr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove attribute index <code>i_attr</code>. </p>
<dl class="section return"><dt>Returns</dt><dd>the new number of attributes or -1 on invalid arguments. </dd></dl>

</div>
</div>
<a id="ad0454f10aabaa5fca405118a0b5f11b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0454f10aabaa5fca405118a0b5f11b7">&#9670;&nbsp;</a></span>XMLNode_remove_child()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XMLNode_remove_child </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sxmlc_8h.html#a2f1120f1eef3bddf7316ed256c0a36a8">XMLNode</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i_child</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>free_child</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove the <code>i_child</code>th <em>active</em> child of the node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>The node. </td></tr>
    <tr><td class="paramname">i_child</td><td>The active node index to retrieve. </td></tr>
    <tr><td class="paramname">free_child</td><td>if <code>true</code>, free the child node itself (and its children, recursively). This parameter is usually <code>true</code> but should be <code>false</code> when child nodes are pointers to local or global variables instead of user-allocated memory. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the new number of children or -1 on invalid arguments. </dd></dl>

</div>
</div>
<a id="a5a7a047035ceb0880423b4ec64350cd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a7a047035ceb0880423b4ec64350cd0">&#9670;&nbsp;</a></span>XMLNode_remove_children()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XMLNode_remove_children </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sxmlc_8h.html#a2f1120f1eef3bddf7316ed256c0a36a8">XMLNode</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove (and frees) all children from the node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>The node. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code>. </dd></dl>

</div>
</div>
<a id="ae563536223635dcf4b8f8d5bf8bb4629"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae563536223635dcf4b8f8d5bf8bb4629">&#9670;&nbsp;</a></span>XMLNode_search_attribute()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XMLNode_search_attribute </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="sxmlc_8h.html#a2f1120f1eef3bddf7316ed256c0a36a8">XMLNode</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="sxmlc_8h.html#a1423a22b82d292ebd77caf61c520cdce">SXML_CHAR</a> *&#160;</td>
          <td class="paramname"><em>attr_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i_search</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Search for the active attribute <code>attr_name</code> in <code>node</code>, starting from index <code>isearch</code> and returns its index, or -1 if not found or error. </p>

</div>
</div>
<a id="a2efacd0f762ed6f686cac9458fb82fdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2efacd0f762ed6f686cac9458fb82fdb">&#9670;&nbsp;</a></span>XMLNode_set_active()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XMLNode_set_active </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sxmlc_8h.html#a2f1120f1eef3bddf7316ed256c0a36a8">XMLNode</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>active</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the active/inactive state of <code>node</code>. </p>
<p>Set <code>active</code> to <code>true</code> to activate <code>node</code> and all its children, and enable its use in other functions (e.g. <code><a class="el" href="sxmlc_8h.html#a9f465e5a3a4bb4f5ed7ad53c929276b5">XMLDoc_print()</a></code>, ...). </p>

</div>
</div>
<a id="a3b07205691114194a903de14cfe7dca9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b07205691114194a903de14cfe7dca9">&#9670;&nbsp;</a></span>XMLNode_set_attribute()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XMLNode_set_attribute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sxmlc_8h.html#a2f1120f1eef3bddf7316ed256c0a36a8">XMLNode</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="sxmlc_8h.html#a1423a22b82d292ebd77caf61c520cdce">SXML_CHAR</a> *&#160;</td>
          <td class="paramname"><em>attr_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="sxmlc_8h.html#a1423a22b82d292ebd77caf61c520cdce">SXML_CHAR</a> *&#160;</td>
          <td class="paramname"><em>attr_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add an attribute to a node or update an existing one. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>The node to which add/update an attribute. </td></tr>
    <tr><td class="paramname">attr_name</td><td>The attribute name. A <em>copy</em> will be assigned through <code>strdup()</code>. </td></tr>
    <tr><td class="paramname">attr_value</td><td>The attribute value. A <em>copy</em> will be assigned through <code>strdup()</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the new number of attributes, or -1 for memory problem. </dd></dl>

</div>
</div>
<a id="aba9597ca92e8244c07e4dd156465cc9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba9597ca92e8244c07e4dd156465cc9a">&#9670;&nbsp;</a></span>XMLNode_set_tag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XMLNode_set_tag </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sxmlc_8h.html#a2f1120f1eef3bddf7316ed256c0a36a8">XMLNode</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="sxmlc_8h.html#a1423a22b82d292ebd77caf61c520cdce">SXML_CHAR</a> *&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set node tag. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>The node to set. </td></tr>
    <tr><td class="paramname">tag</td><td>The tag to set in <code>node</code>. A <em>copy</em> of <code>tag</code> will be assigned to <code>node-&gt;tag</code>, using <code>strdup()</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>false</code> for memory error, <code>true</code> otherwise. </dd></dl>

</div>
</div>
<a id="ab30f788b1b0ca3067e70fb1cfeb5567c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab30f788b1b0ca3067e70fb1cfeb5567c">&#9670;&nbsp;</a></span>XMLNode_set_text()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XMLNode_set_text </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sxmlc_8h.html#a2f1120f1eef3bddf7316ed256c0a36a8">XMLNode</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="sxmlc_8h.html#a1423a22b82d292ebd77caf61c520cdce">SXML_CHAR</a> *&#160;</td>
          <td class="paramname"><em>text</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set node text to a copy of <code>text</code> (from <code>strdup()</code>), or remove text if set to <code>NULL</code>. </p><dl class="section return"><dt>Returns</dt><dd><code>true</code> when successful, <code>false</code> on error. </dd></dl>

</div>
</div>
<a id="acd586c7c50c2159ed91304104d5bc6ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd586c7c50c2159ed91304104d5bc6ec">&#9670;&nbsp;</a></span>XMLNode_set_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XMLNode_set_type </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sxmlc_8h.html#a2f1120f1eef3bddf7316ed256c0a36a8">XMLNode</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="sxmlc_8h.html#ae5087224fc7c4f0dfabdd3ead8c91551">TagType</a>&#160;</td>
          <td class="paramname"><em>tag_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the node type to one of <code>TagType</code> or any user-registered tag. </p>
<dl class="section return"><dt>Returns</dt><dd>'false' when the node or the 'tag_type' is invalid. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
